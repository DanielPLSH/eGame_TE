<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RsaCipher.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sourcecode</a> &gt; <a href="index.html" class="el_package">com.mpos.lottery.te.common.encrypt</a> &gt; <span class="el_source">RsaCipher.java</span></div><h1>RsaCipher.java</h1><pre class="source lang-java linenums">package com.mpos.lottery.te.common.encrypt;

import com.mpos.lottery.te.common.util.Base64Coder;
import com.mpos.lottery.te.config.exception.SystemException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.nio.charset.Charset;
import java.security.Key;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.interfaces.RSAPrivateKey;
import java.security.spec.KeySpec;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.RSAPrivateKeySpec;
import java.security.spec.RSAPublicKeySpec;

import javax.crypto.Cipher;

/**
 * A RSA utility.
 * &lt;p&gt;
 * Key data may be encoded in three general ways:
 * &lt;ol&gt;
 * &lt;li&gt;Binary DER-encoded format. This is sometimes called ASN.1 BER-encoded (there is a subtle difference between BER-
 * and DER-encodings: DER is just a stricter subset of BER). The most compact form. If you try to view the file with a
 * text editor it is full of &quot;funny&quot; characters. The first character in the file is almost always a '0' character
 * (0x30).&lt;/li&gt;
 * &lt;li&gt;PEM or base64 format. This is the same data as the DER-encoded file but it is encoded in base64 with additional
 * header and footer lines: -----BEGIN FOO BAR KEY----- MIIBgjAcBgoqhkiG9w0BDAEDMA4ECKZesfWLQOiDAgID6ASCAWBu7izm8N4V
 * 2puRO/Mdt+Y8ceywxiC0cE57nrbmvaTSvBwTg9b/xyd8YC6QK7lrhC9Njgp/ ... -----END FOO BAR KEY----- These files can be viewed
 * with a text editor and can be easily transmitted as part of an email message.&lt;/li&gt;
 * 
 * &lt;li&gt;XML format. There are W3C standards for this, and, er, a .NET way that predates the latest W3C standard. Here is
 * an example of the W3C [XKMS] 2.0 format.
 * 
 * &lt;pre&gt;
 * &amp;lt;RSAKeyPair&amp;gt;
 *   &amp;lt;Modulus&amp;gt;4IlzOY3Y9fXoh3Y5f06wBbtTg94Pt6vcfcd1KQ0FLm0S36aGJtTSb6pYKfyX7PqCUQ8wgL6xUJ5GRPEsu9
 *     gyz8ZobwfZsGCsvu40CWoT9fcFBZPfXro1Vtlh/xl/yYHm+Gzqh0Bw76xtLHSfLfpVOrmZdwKmSFKMTvNXOFd0V18=
 *   &amp;lt;/Modulus&amp;gt;
 *   &amp;lt;Exponent&amp;gt;AQAB&amp;lt;/Exponent&amp;gt;
 *   &amp;lt;P&amp;gt;9tbgIiFMXwpw/yf85bNQap3lD7WFlsZA+qgKtJubDFXCAR35N4KKFMjykw6SzaVmIbk80ga/tFUxydytypgt0Q==&amp;lt;/P&amp;gt;
 *   &amp;lt;Q&amp;gt;6N6wESUJ0gJRAd6K6JhQ9Xd3YaRFk2sIVZZzXfTIWxKTInOLf9Nwf/Wkqrt0/Twiato4kSqGW2wU6K5MnvqOLw==&amp;lt;/Q&amp;gt;
 *   &amp;lt;DP&amp;gt;l0zwh5sXf+4bgxsUtgtqkF+GJ1Hht6B/9eSI41m5+R6b0yl3OCJI1yKxJZi6PVlTt/oeILLIURYjdZNR56vN8Q==&amp;lt;/DP&amp;gt;
 *   &amp;lt;DQ&amp;gt;LPAkW/qgzYUi6tBuT/pszSHTyOTxhERIZHPXKY9+RozsFd7kUbOU5yyZLVVleyTqo2IfPmxNZ0ERO+G+6YMCgw==&amp;lt;/DQ&amp;gt;
 *   &amp;lt;InverseQ&amp;gt;
 *     WIjZoVA4hGqrA7y730v0nG+4tCol+/bkBS9u4oiJIW9LJZ7Qq1CTyr9AcewhJcV/+wLpIZa4M83ixpXub41fKA==
 *   &amp;lt;/InverseQ&amp;gt;
 *   &amp;lt;D&amp;gt;pAPDJ0d2NDRspoa1eUkBSy6K0shissfXSAlqi5H3NvJ11ujNFZBgJzFHNWRNlc1nY860n1asLzduHO4Ovygt9DmQb
 *     zTYbghb1WVq2EHzE9ctOV7+M8v/KeQDCz0Foo+38Y6idjeweVfTLyvehwYifQRmXskbr4saw+yRRKt/IQ==
 *   &amp;lt;/D&amp;gt;
 * &amp;lt;/RSAKeyPair&amp;gt;
 * &lt;/pre&gt;
 * 
 * &lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;p&gt;
 * The white space should not matter, at least for our functions. The .NET version uses &lt;RsaKeyValue&gt; instead, which is
 * strictly only for a public key.
 * &lt;p&gt;
 * Refer to:
 * &lt;ul&gt;
 * &lt;li&gt;http://www.cryptosys.net/pki/rsakeyformats.html&lt;/li&gt;
 * &lt;li&gt;
 * http://stackoverflow.com/questions/3243018/how-to-load-rsa-private-key-from -file&lt;/li&gt;
 * &lt;/ul&gt;
 */
<span class="nc" id="L81">public class RsaCipher {</span>
    private static final String TOKEN_MOD_BEGIN = &quot;&lt;Modulus&gt;&quot;;
    private static final String TOKEN_MOD_END = &quot;&lt;/Modulus&gt;&quot;;
    private static final String TOKEN_EXP_BEGIN = &quot;&lt;Exponent&gt;&quot;;
    private static final String TOKEN_EXP_END = &quot;&lt;/Exponent&gt;&quot;;
    private static final String ALG_NAME = &quot;RSA&quot;;
    private static final String PROVIDER = &quot;SunRsaSign&quot;; // refer to
                                                         // $jre_home/lib/security/java.security
    // private static final String ENCODING = &quot;UTF-8&quot;;
    private static final String ENCODING = &quot;ISO-8859-1&quot;;
    // transformation: algorithm/mode/padding
    private static final String ALG_TRANSFORMATION = &quot;RSA/ECB/PKCS1Padding&quot;;
    // private static SecureRandom randomSeed = new SecureRandom(new byte[1]);
<span class="fc" id="L94">    private static Log logger = LogFactory.getLog(RsaCipher.class);</span>

    /**
     * Generate RSA key pair, refer to http://stackoverflow.com/questions/3171481/publickey-vs-rsapublickeyspec
     * 
     * @return The public/private KeySpec array. The first element is &lt;code&gt;RSAPublicKeySpec&lt;/code&gt;, the second is
     *         &lt;/code&gt;RSAPrivateKeySpec&lt;/code&gt;.
     * @throws Exception
     *             when encounter any exceptions.
     */
    public static KeySpec[] generateKeyPair(int keySize) throws Exception {
        // Get the public/private key pair
<span class="nc" id="L106">        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(ALG_NAME);</span>
<span class="nc" id="L107">        keyGen.initialize(keySize);</span>
<span class="nc" id="L108">        KeyPair keyPair = keyGen.genKeyPair();</span>

        // For public keys, it doesn't make much difference with KeySpec. For
        // private keys, getEncoded() returns much more information than the
        // private key.
        // PrivateKey privateKey = keyPair.getPrivate();
        // PublicKey publicKey = keyPair.getPublic();

<span class="nc" id="L116">        KeyFactory fact = KeyFactory.getInstance(ALG_NAME);</span>
<span class="nc" id="L117">        RSAPublicKeySpec pub = fact.getKeySpec(keyPair.getPublic(), RSAPublicKeySpec.class);</span>
<span class="nc" id="L118">        RSAPrivateKeySpec priv = fact.getKeySpec(keyPair.getPrivate(), RSAPrivateKeySpec.class);</span>

<span class="nc" id="L120">        return new KeySpec[] { pub, priv };</span>
    }

    /**
     * This method will encode modulus and publicExponent by Base64, and return them in XML representation like below:
     * &lt;p&gt;
     * &lt;RSAKeyValue&gt;&lt;Modulus&gt;u4hzNOuqRWaJVvH6C+w/h8/IzqtPaAZE1+2+0Aktj/
     * UL0bm9PiuYZH7VZCrGsQCS89ZOuV96tHXPCWS6jr0blRWkkZqt1CMY +4AjZevXM6VXK2ZohrtbSZ95n6XQZu2Zwflq
     * +qqZTcyCbLUrkT61eSIHVIgdoU/aKGpMH+PeKU =&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt;
     * 
     * @param keySize
     *            The size of RSA key.
     * @return a String array, the first one is XML representation of public key, and the second is XML representation
     *         of private key.
     * @throws Exception
     *             when encounter any exceptions.
     */
    public static String[] generateXmlKeyPair(int keySize) throws Exception {
<span class="nc" id="L138">        KeySpec[] keySpecs = generateKeyPair(keySize);</span>
<span class="nc" id="L139">        RSAPublicKeySpec pub = (RSAPublicKeySpec) keySpecs[0];</span>
<span class="nc" id="L140">        String keys[] = new String[2];</span>
<span class="nc" id="L141">        keys[0] = assembleXMLKeyPair(pub.getModulus(), pub.getPublicExponent());</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L143">            logger.debug(&quot;Generate RSA public key:&quot; + keys[0]);</span>
        }
<span class="nc" id="L145">        RSAPrivateKeySpec priv = (RSAPrivateKeySpec) keySpecs[1];</span>
<span class="nc" id="L146">        keys[1] = assembleXMLKeyPair(priv.getModulus(), priv.getPrivateExponent());</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L148">            logger.debug(&quot;Generate RSA private key:&quot; + keys[1]);</span>
        }
<span class="nc" id="L150">        return keys;</span>
    }

    private static String assembleXMLKeyPair(BigInteger modulus, BigInteger publicExponent) {
<span class="nc" id="L154">        StringBuffer buffer = new StringBuffer(&quot;&lt;RSAKeyValue&gt;&quot;);</span>
<span class="nc" id="L155">        buffer.append(TOKEN_MOD_BEGIN).append(new String(Base64Coder.encode(modulus.toByteArray())));</span>
<span class="nc" id="L156">        buffer.append(TOKEN_MOD_END).append(TOKEN_EXP_BEGIN);</span>
<span class="nc" id="L157">        buffer.append(new String(Base64Coder.encode(publicExponent.toByteArray())));</span>
<span class="nc" id="L158">        buffer.append(TOKEN_EXP_END).append(&quot;&lt;/RSAKeyValue&gt;&quot;);</span>
<span class="nc" id="L159">        return buffer.toString();</span>
    }

    /**
     * Encrypt raw input string by public key.
     * 
     * @param publicKeyFile
     *            The file path of public key.
     * @param input
     *            The raw input string.
     * @return a base64 encoded output string.
     */
    public static String encrypt(String publicKeyFile, String input) {
<span class="fc" id="L172">        PublicKey publicKey = (PublicKey) getKeyFromFile(new File(publicKeyFile), true);</span>
<span class="fc" id="L173">        byte[] inputByte = input.getBytes(Charset.forName(ENCODING));</span>
<span class="fc" id="L174">        byte[] outputByte = encrypt(publicKey, inputByte);</span>
<span class="fc" id="L175">        String encryption = new String(Base64Coder.encode(outputByte));</span>
        // if (logger.isDebugEnabled()){
        // logger.debug(&quot;Input:&quot; + input + &quot;,Encrytpion:&quot; + encryption);
        // }
<span class="fc" id="L179">        return encryption;</span>
    }

    /**
     * Encrypt by public key
     * 
     * @param xmlKey
     *            The XMl formatted public key
     * @param input
     *            The bytes to be encrypted.
     * @return The encrypted bytes.
     */
    public static byte[] encrypt(String xmlKey, byte[] input) {
<span class="nc" id="L192">        PublicKey publicKey = (PublicKey) getKeyFromXml(xmlKey, true);</span>
<span class="nc" id="L193">        return encrypt(publicKey, input);</span>
    }

    public static byte[] encrypt(Key publicKey, byte input[]) {
        try {
            // get an RSA cipher object and print the
            // provider...&quot;algorithm/mode/padding&quot;
<span class="fc" id="L200">            Cipher cipher = Cipher.getInstance(ALG_TRANSFORMATION);</span>

<span class="fc" id="L202">            SecureRandom randomSeed = new SecureRandom(new byte[] { 1 });</span>
            // encrypt the plain-text using the public key and a specified
            // random seed. If you don't
            // specify a fixed random seed, the same input and same public key
            // will generate different
            // output each time when you do encryption. Besides the SecureRandom
            // must not be a instance
            // variable, looks like the 'init' method will manipulate the random
            // seed. If the seed
            // is a instance variable, different seed will be passed to 'init'
            // method each time.
<span class="fc" id="L213">            cipher.init(Cipher.ENCRYPT_MODE, publicKey, randomSeed);</span>
<span class="fc" id="L214">            return cipher.doFinal(input);</span>
<span class="nc" id="L215">        } catch (Exception e) {</span>
<span class="nc" id="L216">            throw new SystemException(e);</span>
        }
    }

    /**
     * Decrypt a cipher back into original data.
     * 
     * @param privateKeyPath
     *            The file path of private key.
     * @param base64Input
     *            The base64 encoded cipher.
     * @return the original raw text.
     */
    public static String decrypt(String privateKeyPath, String base64Input) {
<span class="fc" id="L230">        PrivateKey privateKey = (PrivateKey) getKeyFromFile(new File(privateKeyPath), false);</span>
<span class="fc" id="L231">        byte[] input = Base64Coder.decode(base64Input);</span>
<span class="fc" id="L232">        byte[] output = decrypt(privateKey, input);</span>
<span class="fc" id="L233">        return new String(output);</span>
    }

    /**
     * Decrypt by private key
     * 
     * @param xmlKey
     *            The XMl formatted private key
     * @param cipher
     *            The encrypted bytes.
     * @return The raw bytes.
     */
    public static byte[] decrypt(String xmlKey, byte[] cipher) {
<span class="fc" id="L246">        PrivateKey privateKey = (PrivateKey) getKeyFromXml(xmlKey, false);</span>
<span class="fc" id="L247">        return decrypt(privateKey, cipher);</span>
    }

    public static byte[] decrypt(Key privateKey, byte input[]) {
        try {
<span class="fc" id="L252">            Cipher cipher = Cipher.getInstance(ALG_TRANSFORMATION);</span>
<span class="fc" id="L253">            cipher.init(Cipher.DECRYPT_MODE, privateKey);</span>
<span class="fc" id="L254">            return cipher.doFinal(input);</span>
<span class="nc" id="L255">        } catch (Exception e) {</span>
<span class="nc" id="L256">            throw new SystemException(e);</span>
        }
    }

    /**
     * Retrieve public/private key from file, which is a XML file.
     */
    private static Key getKeyFromFile(File keyFilePath, boolean isPublic) {
<span class="fc" id="L264">        StringBuffer buffer = new StringBuffer();</span>
        try {
<span class="fc" id="L266">            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(keyFilePath)));</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">            for (String line = br.readLine(); line != null;) {</span>
<span class="fc" id="L268">                buffer.append(line);</span>
<span class="fc" id="L269">                line = br.readLine();</span>
            }
<span class="fc" id="L271">            br.close();</span>
<span class="fc" id="L272">            return getKeyFromXml(buffer.toString(), isPublic);</span>
<span class="nc" id="L273">        } catch (Exception e) {</span>
<span class="nc" id="L274">            throw new SystemException(e);</span>
        }
    }

    /**
     * Retrieve public/private key from file, which is XML formatted.
     */
    private static Key getKeyFromXml(String xmlKeyString, boolean isPublic) {
        try {
<span class="fc" id="L283">            String keyString = xmlKeyString;</span>
<span class="fc" id="L284">            String base64Mod = getKeyComponent(keyString, true);</span>
<span class="fc" id="L285">            String base64Exp = getKeyComponent(keyString, false);</span>
            // if (logger.isDebugEnabled()){
            // logger.debug(&quot;MOD:&quot; + base64Mod + &quot;,EXP:&quot; + base64Exp);
            // }
            // convert base64 into BigInteger
<span class="fc" id="L290">            BigInteger mod = new BigInteger(Base64Coder.decode(base64Mod));</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">            if (mod.compareTo(new BigInteger(&quot;0&quot;)) &lt; 0) {</span>
                /**
                 * javax.crypto.BadPaddingException: Message is larger than modulus ... You just need to add a check for
                 * a negative modulus coming from the card. In RSA encryption, you use large integers for the
                 * calculation. Even the message is converted to a large integer. For the equation to work, the message
                 * has to be smaller than the modulus. Luckily the solution is simple. If the first bit of your modulus
                 * from the card is set, add a 0x00 byte to front before setting the modulus in your key spec instance.
                 * Refer to http://forums.oracle.com/forums/thread.jspa?threadID=1749350
                 */
<span class="nc" id="L300">                mod = mod.multiply(new BigInteger(&quot;-1&quot;));</span>
            }
<span class="fc" id="L302">            BigInteger exp = new BigInteger(Base64Coder.decode(base64Exp));</span>

<span class="fc" id="L304">            Key key = null;</span>
<span class="fc" id="L305">            KeyFactory fac = KeyFactory.getInstance(ALG_NAME, PROVIDER);</span>
            // if (logger.isDebugEnabled()){
            // logger.debug(&quot;The provider for &quot; + ALG_NAME + &quot;:&quot; +
            // fac.getProvider().getName());
            // // showProvider(fac.getProvider());
            // }
<span class="fc bfc" id="L311" title="All 2 branches covered.">            if (isPublic) {</span>
<span class="fc" id="L312">                RSAPublicKeySpec pub = new RSAPublicKeySpec(mod, exp);</span>
<span class="fc" id="L313">                key = fac.generatePublic(pub);</span>
<span class="fc" id="L314">            } else {</span>
<span class="fc" id="L315">                RSAPrivateKeySpec pri = new RSAPrivateKeySpec(mod, exp);</span>
<span class="fc" id="L316">                key = fac.generatePrivate(pri);</span>
            }
<span class="fc" id="L318">            return key;</span>
<span class="nc" id="L319">        } catch (Exception e) {</span>
<span class="nc" id="L320">            throw new SystemException(e);</span>
        }
    }

    /**
     * Read private/public key from a .pem file which often generated from openssl. In general, there are three things
     * to construct a &lt;code&gt;Key&lt;/code&gt; .
     * &lt;ol&gt;
     * &lt;li&gt;Filter those comment lines, for example '-----BEGIN RSA PRIVATE KEY-----' in a non-encrypted .pem file.&lt;/li&gt;
     * &lt;li&gt;Base64 decode the content.&lt;/li&gt;
     * &lt;li&gt;The openssl private key format is non-standard and is not compatible with &lt;code&gt;PKCS8EncodedKeySpec.&lt;/code&gt;&lt;/li&gt;
     * &lt;/ol&gt;
     * NOTE: refer to http://stackoverflow.com/questions/3243018/how-to-load-rsa- private-key-from-file.
     * &lt;p&gt;
     * As the .pem file generate by openssl is not compatible with &lt;code&gt;PKCS8EncodedKeySpec.&lt;/code&gt;, You need to
     * convert your private key to PKCS8 format using following command:
     * &lt;p&gt;
     * &lt;code&gt;openssl pkcs8 -topk8 -inform PEM -outform DER -in private_key_file  -nocrypt &gt; pkcs8_key&lt;/code&gt;
     * &lt;p&gt;
     * This command will convert .pem into a Binary DER-encoded format(refer to
     * http://www.cryptosys.net/pki/rsakeyformats.html).
     * &lt;p&gt;
     * Also if you wanna handle with .pem, there is a convenient alternative: &lt;a
     * href=&quot;http://www.bouncycastle.org/&quot;&gt;bouncycastle&lt;/a&gt;
     * 
     * @param pemKeyFile
     *            The path of .pem file.
     * @param isPublic
     *            Is this a public key file?
     * @return a RSA key, public or private
     */
    public static Key getKeyFromPKCS8(String pemKeyFile, boolean isPublic) {
<span class="nc" id="L352">        Key key = null;</span>
        // read key file
<span class="nc" id="L354">        BufferedInputStream bis = null;</span>
        try {
<span class="nc" id="L356">            File keyFile = new File(pemKeyFile);</span>
<span class="nc" id="L357">            bis = new BufferedInputStream(new FileInputStream(keyFile));</span>
<span class="nc" id="L358">            byte[] keyBytes = new byte[(int) keyFile.length()];</span>
<span class="nc" id="L359">            bis.read(keyBytes);</span>
<span class="nc" id="L360">            bis.close();</span>

            // System.out.println(Base64Coder.encode(keyBytes));
            // StringBuffer buffer = new StringBuffer();
            // BufferedReader br = new BufferedReader(new InputStreamReader(new
            // FileInputStream(
            // pemKeyFile)));
            // for (String line = br.readLine(); line != null;) {
            // buffer.append(line);
            // line = br.readLine();
            // }
            // br.close();
            // // remove comments
            // String pemStr = buffer.toString();
            // String keyPEM = pemStr.replace(&quot;-----BEGIN RSA PRIVATE KEY-----&quot;,
            // &quot;&quot;);
            // keyPEM = keyPEM.replace(&quot;-----END RSA PRIVATE KEY-----&quot;, &quot;&quot;);
            // byte[] keyBytes = Base64Coder.decode(keyPEM);

<span class="nc" id="L379">            KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);</span>
<span class="nc" id="L380">            KeySpec ks = new PKCS8EncodedKeySpec(keyBytes);</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">            if (isPublic) {</span>
<span class="nc" id="L382">                key = keyFactory.generatePublic(ks);</span>
            } else {
<span class="nc" id="L384">                key = (RSAPrivateKey) keyFactory.generatePrivate(ks);</span>
            }
<span class="nc" id="L386">        } catch (Exception e) {</span>
<span class="nc" id="L387">            throw new RuntimeException(e);</span>
<span class="nc" id="L388">        }</span>
<span class="nc" id="L389">        return key;</span>
    }

    private static String getKeyComponent(String keyString, boolean isModulus) {
<span class="fc" id="L393">        int indexBegin = -1;</span>
<span class="fc" id="L394">        int indexEnd = -1;</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">        if (isModulus) {</span>
<span class="fc" id="L396">            indexBegin = keyString.indexOf(TOKEN_MOD_BEGIN) + TOKEN_MOD_BEGIN.length();</span>
<span class="fc" id="L397">            indexEnd = keyString.indexOf(TOKEN_MOD_END);</span>
        } else {
<span class="fc" id="L399">            indexBegin = keyString.indexOf(TOKEN_EXP_BEGIN) + TOKEN_EXP_BEGIN.length();</span>
<span class="fc" id="L400">            indexEnd = keyString.indexOf(TOKEN_EXP_END);</span>
        }
<span class="pc bpc" id="L402" title="2 of 4 branches missed.">        if (indexBegin == -1 || indexEnd == -1) {</span>
<span class="nc" id="L403">            throw new SystemException(&quot;Wrong key format:&quot; + keyString);</span>
        }
<span class="fc" id="L405">        return keyString.substring(indexBegin, indexEnd).trim();</span>
    }

    @SuppressWarnings(&quot;unused&quot;)
    private static void showProvider(Provider provider) {
<span class="nc bnc" id="L410" title="All 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L411">            logger.debug(&quot;\tProvider: &quot; + provider.getName());</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">            for (java.util.Iterator itr = provider.keySet().iterator(); itr.hasNext();) {</span>
<span class="nc" id="L413">                String key = (String) itr.next();</span>
<span class="nc" id="L414">                String value = (String) provider.get(key);</span>
<span class="nc" id="L415">                logger.debug(&quot;\t&quot; + key + &quot; = &quot; + value);</span>
<span class="nc" id="L416">            }</span>
        }
<span class="nc" id="L418">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.2.201302030002</span></div></body></html>