<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractRiskControlService.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sourcecode</a> &gt; <a href="index.html" class="el_package">com.mpos.lottery.te.gamespec.sale.service</a> &gt; <span class="el_source">AbstractRiskControlService.java</span></div><h1>AbstractRiskControlService.java</h1><pre class="source lang-java linenums">package com.mpos.lottery.te.gamespec.sale.service;

import com.google.gson.Gson;

import com.mpos.lottery.te.common.util.Combination;
import com.mpos.lottery.te.common.util.SimpleToolkit;
import com.mpos.lottery.te.config.exception.ApplicationException;
import com.mpos.lottery.te.config.exception.SystemException;
import com.mpos.lottery.te.gamespec.game.BaseGameInstance;
import com.mpos.lottery.te.gamespec.game.GameType;
import com.mpos.lottery.te.gamespec.sale.BaseEntry;
import com.mpos.lottery.te.gamespec.sale.BaseTicket;
import com.mpos.lottery.te.gamespec.sale.InstantaneousSale;
import com.mpos.lottery.te.gamespec.sale.RiskControlLog;
import com.mpos.lottery.te.gamespec.sale.dao.InstantaneousSaleDao;
import com.mpos.lottery.te.gamespec.sale.dao.RiskControlLogDao;
import com.mpos.lottery.te.gamespec.sale.support.ChanceOdds;
import com.mpos.lottery.te.gamespec.sale.support.ChanceOfEntry;
import com.mpos.lottery.te.port.Context;
import com.mpos.lottery.te.trans.domain.TransactionMessage;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.perf4j.StopWatch;
import org.perf4j.log4j.Log4JStopWatch;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

@SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L37">public abstract class AbstractRiskControlService implements RiskControlService {</span>
<span class="fc" id="L38">    private Log logger = LogFactory.getLog(AbstractRiskControlService.class);</span>
    private static final String KEY_JSONTRANS_RISKLOG = &quot;riskLogs&quot;;
<span class="fc" id="L40">    private final Object lock = new Object();</span>
    // SPRING DEPENDENCIES
    private InstantaneousSaleDao instantaneousSaleDao;
    private RiskControlLogDao riskControlLogDao;
    private RiskControlLogServiceAsyn riskControlLogServiceAsyn;
    @PersistenceContext(unitName = &quot;lottery_te&quot;)
    private EntityManager entityManager;

    @Override
    public void riskControl(Context respCtx, BaseTicket ticket, List&lt;? extends BaseGameInstance&gt; gameInstances)
            throws ApplicationException {
        /**
         * Record the transaction message for later possible cancellation, its format will be
         * {&quot;data&quot;:[{&quot;Id_riskControlLog#1&quot;:bet_amount},{&quot;Id_riskControlLog#2&quot; :bet_amount }...{}]}
         * &lt;p/&gt;
         * Refer to {@link JsonRiskControlTrans}
         */
<span class="fc" id="L57">        JsonRiskControlTrans jsonTrans = new JsonRiskControlTrans();</span>

<span class="fc bfc" id="L59" title="All 2 branches covered.">        for (BaseGameInstance gameInstance : gameInstances) {</span>
<span class="fc" id="L60">            StopWatch sw = new Log4JStopWatch();</span>

<span class="fc bfc" id="L62" title="All 2 branches covered.">            for (BaseEntry entry : ticket.getEntries()) {</span>
                // determine the final limit
<span class="fc" id="L64">                BigDecimal finalLimit = this.determineFinalLimit(entry, ticket, gameInstance);</span>
<span class="fc" id="L65">                this.doRiskConrolOnEntry(respCtx, ticket, gameInstance, entry, finalLimit, jsonTrans);</span>
<span class="fc" id="L66">            }</span>
<span class="fc" id="L67">            sw.stop(&quot;Risk_Control&quot;,</span>
                    &quot;Risk control of ticket(&quot; + ticket.getSerialNo() + &quot;) of game type(&quot;
                            + GameType.fromType(gameInstance.getGame().getType()) + &quot;)&quot;);
<span class="fc" id="L70">        }</span>

<span class="fc" id="L72">        TransactionMessage transMsg = new TransactionMessage();</span>
<span class="fc" id="L73">        transMsg.setTransactionId(respCtx.getTransaction().getId());</span>
<span class="fc" id="L74">        respCtx.getTransaction().setTransMessage(transMsg);</span>
        // add response JSON entry
<span class="fc" id="L76">        transMsg.addRespJsonEntry(KEY_JSONTRANS_RISKLOG, jsonTrans.getRiskLogs());</span>
<span class="fc" id="L77">    }</span>

    @Override
    public void cancelRiskControl(Context respCtx, List&lt;? extends BaseTicket&gt; hostTickets) throws ApplicationException {
        // lookup the cancelled sale transaction
<span class="fc" id="L82">        TransactionMessage saleTransaction = this.getEntityManager().find(TransactionMessage.class,</span>
                respCtx.getTransaction().getCancelTransactionId());
<span class="fc" id="L84">        JsonRiskControlTrans riskTrans = new Gson().fromJson(saleTransaction.getResponseMsg(),</span>
                JsonRiskControlTrans.class);
        // cancel those logs one by one
<span class="fc bfc" id="L87" title="All 2 branches covered.">        for (JsonRiskControlTransItem logItem : riskTrans.getRiskLogs()) {</span>
<span class="fc" id="L88">            this.getRiskControlLogDao().updateWithAmount(logItem.getId(),</span>
                    logItem.getAmount().multiply(new BigDecimal(&quot;-1&quot;)));
<span class="fc" id="L90">        }</span>
<span class="fc" id="L91">    }</span>

    /**
     * Apply risk control on given entry. 
     * 
     * @param respCtx
     *            The context of current sale transaction.
     * @param ticket
     *            The ticket which contains given entry.
     * @param gameInstance
     *            In which the turnover will be verified...consider a multi-draw ticket.
     * @param entry
     *            Apply risk control method on this entry.
     * @param finalLimit
     *            The final amount of loss.
     * @param jsonTrans
     *            The transaction log which will be used when cancellation.
     */
    protected final void doRiskConrolOnEntry(Context respCtx, BaseTicket ticket, BaseGameInstance gameInstance,
            BaseEntry entry, BigDecimal finalLimit, JsonRiskControlTrans jsonTrans) throws ApplicationException {
<span class="fc" id="L111">        List&lt;ChanceOdds&gt; chanceOdds = this.determineOddsOfEntry(respCtx, ticket, gameInstance, entry);</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">        if (chanceOdds == null) {</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">            if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L114">                logger.debug(&quot;There is no any possible prize levels found for entry(&quot; + entry + &quot;)&quot;);</span>
            }
<span class="nc" id="L116">            return;</span>
        }

<span class="fc" id="L119">        List&lt;ChanceOfEntry&gt; chances = this.determineSelectedNumbers(respCtx, ticket, gameInstance, entry);</span>
<span class="fc" id="L120">        BigDecimal finalLossAmountOfPrizeLevel = determineFinalLossAmountOfPrizeLevel(finalLimit, chanceOdds,</span>
                gameInstance);

<span class="fc bfc" id="L123" title="All 2 branches covered.">        for (ChanceOfEntry chance : chances) {</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">            for (ChanceOdds chanceOdd : chanceOdds) {</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">                if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L126">                    logger.debug(&quot;Prepare to generate risk control log of &quot; + chanceOdd);</span>
                }
                // determine betting number of each possible prize levels
<span class="fc" id="L129">                String bettingNumber = this.determineBettingNumberOfPrizeLevel(respCtx, entry, chanceOdd, chance);</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">                if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L131">                    logger.debug(&quot;Determine the odds of betting number(&quot; + bettingNumber + &quot;, amount=&quot;</span>
                            + chance.getAmount() + &quot;) is &quot; + chanceOdd.getOdds());
                }
                // lookup RiskControlLog first
<span class="fc" id="L135">                RiskControlLog riskLog = null;</span>
                /**
                 * There are 3 questions:
                 * &lt;ol&gt;
                 * &lt;li&gt;Why needs a synchronized block here?&lt;/li&gt;
                 * &lt;li&gt;Why needs a &lt;code&gt;RiskControlLogServiceAsyn&lt;/code&gt;?&lt;/li&gt;
                 * &lt;li&gt;Why the &lt;code&gt;RiskControlLogServiceAsyn&lt;/code&gt; create a default risk control log whose total
                 * amount is 0?&lt;/li&gt;
                 * &lt;/ol&gt;
                 * &lt;li&gt;Why needs a synchronized block here?&lt;/li&gt;
                 * &lt;p/&gt;
                 * Simple answer is to avoid generating duplicated records of same game instance and selected number in
                 * multi-threads environment. THe synchronized block guarantee that only one thread can create the new
                 * risk control log (actually per TE instance).
                 * &lt;p/&gt;
                 * Now why need a &lt;code&gt;RiskControlLogServiceAsyn&lt;/code&gt;?
                 * &lt;p/&gt;
                 * Lets imagine that there are two threads reach the entry point of this synchronized block, one thread
                 * go through the block, and it creates a risk control log, but as its transaction doesn't commit, even
                 * the other thread troop in the synchronized block, it won't see the record created by 1st thread, so
                 * it will create a duplicated risk control log.
                 * &lt;p/&gt;
                 * To avoid this, the logic of create a risk control log must be wrapped in a isolated transaction. In
                 * TE transaction definition, any service whose name ends with 'ServiceAsyn' will require a new
                 * transaction.
                 * &lt;p/&gt;
                 * Now it is time to answer why to create a default risk control log?
                 * &lt;p/&gt;
                 * The answer is connected to the 2nd question. As the creation of risk control log is happened in a new
                 * transaction, so if the outer transaction of the synchronized block rolled back, how to roll back the
                 * generated risk control log?? So now I will simply create a default risk control log, and then update
                 * it in the outer transaction.
                 */
<span class="fc" id="L168">                synchronized (lock) {</span>
<span class="fc" id="L169">                    riskLog = this.getRiskControlLogDao().findByGameInstanceAndSelectedNumber(gameInstance.getId(),</span>
                            bettingNumber, chanceOdd.getPrizeLevelTypeInt());
<span class="fc bfc" id="L171" title="All 2 branches covered.">                    if (riskLog == null) {</span>
<span class="fc" id="L172">                        riskLog = this.getRiskControlLogServiceAsyn().createDefault(gameInstance.getId(),</span>
                                bettingNumber, chanceOdd.getPrizeLevelTypeInt());
                    } else {
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">                        if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L176">                            logger.debug(&quot;found risk control log &quot; + riskLog);</span>
                        }
                    }
<span class="pc" id="L179">                }</span>
<span class="fc" id="L180">                BigDecimal riskPrizeAmount = this.determineRiskPrizeAmount(respCtx, riskLog, ticket, gameInstance,</span>
                        entry, chance, chanceOdd);
<span class="fc bfc" id="L182" title="All 2 branches covered.">                if (riskPrizeAmount.compareTo(finalLossAmountOfPrizeLevel) &gt; 0) {</span>
<span class="fc" id="L183">                    throw new ApplicationException(SystemException.CODE_OUT_OF_RISK_CONTROL, &quot;The riskPrizeAmount(&quot;</span>
                            + riskPrizeAmount + &quot;) of bettng number(&quot; + bettingNumber + &quot;) of entry(&quot; + entry
                            + &quot;) exceeds the risk limit(&quot; + finalLossAmountOfPrizeLevel + &quot;) of prizelelve type:&quot;
                            + chanceOdd.getPrizelLevelType() + &quot;.&quot;);
                } else {
                    // update risk control log
<span class="fc" id="L189">                    riskLog.setTotalAmount(riskLog.getTotalAmount());</span>
<span class="fc" id="L190">                    this.riskControlLogDao.updateWithAmount(riskLog.getId(), chance.getAmount());</span>

<span class="fc" id="L192">                    JsonRiskControlTransItem jsonTransItem = new JsonRiskControlTransItem();</span>
<span class="fc" id="L193">                    jsonTransItem.setId(riskLog.getId());</span>
<span class="fc" id="L194">                    jsonTransItem.setAmount(chance.getAmount());</span>
<span class="fc" id="L195">                    jsonTrans.merge(jsonTransItem);</span>
                }
<span class="fc" id="L197">            }</span>
<span class="fc" id="L198">        }</span>

<span class="fc" id="L200">    }</span>

    /**
     * Determine the final loss amount of a prize level. In general it should be
     * &lt;code&gt;(finalLimit/countOfPrizeLevelOfGameInstance)&lt;/code&gt;
     * 
     * @param finalLimit
     *            The allowed loss prize amount of a game instance.
     * @param chanceOdds
     *            THose chance odds of a given entry.
     * @param gameInstance
     *            the game instance of current sale.
     * @return The final loss amount of a prize level
     */
    protected abstract BigDecimal determineFinalLossAmountOfPrizeLevel(BigDecimal finalLimit,
            List&lt;ChanceOdds&gt; chanceOdds, BaseGameInstance gameInstance) throws ApplicationException;

    /**
     * Determine the betting number of a specific prize level. For example a '4D' entry '2,0,1,4' may win 'First4D',
     * 'first3D' and 'last3d', then the betting number of each prize level types will be,
     * &lt;ul&gt;
     * &lt;li&gt;first4d - 2,0,1,4&lt;/li&gt;
     * &lt;li&gt;first3d - 2,0,1&lt;/li&gt;
     * &lt;li&gt;last3d - 0,1,4&lt;/li&gt;
     * &lt;/ul&gt;
     * 
     * @param respCtx
     *            The context of current transaction.
     * @param entry
     *            the ticket entry.
     * @param chanceOdd
     *            The odds and prize level type of a given chance.
     * @param chance
     *            The chance which may win a prize.
     * @return the betting number of a specific prize level
     * @throws ApplicationException
     *             if encounter any biz exception.
     */
    protected abstract String determineBettingNumberOfPrizeLevel(Context respCtx, BaseEntry entry,
            ChanceOdds chanceOdd, ChanceOfEntry chance) throws ApplicationException;

    /**
     * Calculate the risk prize amount.
     */
    protected BigDecimal determineRiskPrizeAmount(Context respCtx, RiskControlLog riskLog, BaseTicket ticket,
            BaseGameInstance gameInstance, BaseEntry entry, ChanceOfEntry chance, ChanceOdds chanceOdds) {
<span class="fc" id="L246">        return SimpleToolkit.mathMultiple(chance.getAmount().add(riskLog.getTotalAmount()), chanceOdds.getOdds());</span>
    }

    /**
     * Determine the odds of given entry. Even a multiple entry, all single selected number share the same odds.The risk
     * prize amount should be the max prize amount a selected number possibly win.
     * 
     * @param respCtx
     *            The context of sale transaction.
     * @param ticket
     *            The sold ticket.
     * @param gameInstance
     *            In which the turnover will be verified. The ticket.getGameInstance() will always return the game
     *            instance which is the one in which the ticket is sold.
     * @param entry
     *            The entry from which the single selected numbers derived.
     * @return All possible prize levels a entry may win
     * @throws ApplicationException
     *             if fail to get risk prize amount.
     */
    protected abstract List&lt;ChanceOdds&gt; determineOddsOfEntry(Context respCtx, BaseTicket ticket,
            BaseGameInstance gameInstance, BaseEntry entry) throws ApplicationException;

    /**
     * Determine how many chances derived from given entry, for example a 'multiple' selected number can generate many
     * 'single' selected number, and each 'single' selected number is a chance.
     * &lt;p/&gt;
     * The subclass can override this.
     */
    protected List&lt;ChanceOfEntry&gt; determineSelectedNumbers(Context respCtx, BaseTicket ticket,
            BaseGameInstance gameInstance, BaseEntry entry) {
<span class="fc" id="L277">        return Arrays.asList(new ChanceOfEntry(entry.getSelectNumber(), entry.getEntryAmount(), entry.getBetOption()));</span>
    }

    /**
     * Determine the final limit. The final limit is up to the risk control method. For 'max loss method', the final
     * limit will be &lt;code&gt;gameInstance.maxLossAmount&lt;/code&gt;. If 'dynamic method', the final limit will be
     * &lt;code&gt;max(gameInstance.maxLossAmount, turnover*gameInstance.percentageOfTurnover)&lt;/code&gt;
     * 
     * @param entry
     *            The entry which will apply risk control checking on.
     * @param ticket
     *            The sold ticket.
     * @param gameInstance
     *            the game instance in which the turnover will be counted...think about multi-draw ticket.
     * @return the final limit of risk control.
     */
    protected BigDecimal determineFinalLimit(BaseEntry entry, BaseTicket ticket, BaseGameInstance gameInstance) {
<span class="fc" id="L294">        int riskControlMethod = gameInstance.getRiskControlMethod();</span>
<span class="fc" id="L295">        BigDecimal finalLimit = new BigDecimal(&quot;0&quot;);</span>
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        if (BaseGameInstance.RISKCONTROL_METHOD_MAX_LOSS == riskControlMethod) {</span>
<span class="fc" id="L297">            finalLimit = gameInstance.getMaxLossAmount();</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">        } else if (BaseGameInstance.RISKCONTROL_METHOD_DYNAMIC == riskControlMethod) {</span>
<span class="nc" id="L299">            finalLimit = gameInstance.getMaxLossAmount();</span>
<span class="nc" id="L300">            InstantaneousSale insSale = this.getInstantaneousSaleDao().findByGameDraw(gameInstance.getId());</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">            if (insSale != null) {</span>
<span class="nc" id="L302">                BigDecimal percentageTurnover = SimpleToolkit.mathMultiple(</span>
                        insSale.getTurnover().add(
                                SimpleToolkit.mathDivide(ticket.getTotalAmount(),
                                        new BigDecimal(ticket.getMultipleDraws()))),
                        gameInstance.getPercentageOfTurnover());
<span class="nc bnc" id="L307" title="All 2 branches missed.">                if (percentageTurnover.compareTo(finalLimit) &gt; 0) {</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">                    if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L309">                        logger.debug(&quot;The final limit of dynamic rick control method(maxLoss:&quot;</span>
                                + gameInstance.getMaxLossAmount() + &quot;,turnPercentage:&quot; + percentageTurnover
                                + &quot;) of ticket(&quot; + ticket.getSerialNo() + &quot;)&quot;);
                    }
<span class="nc" id="L313">                    finalLimit = percentageTurnover;</span>
                }
            }
<span class="nc" id="L316">        } else {</span>
<span class="nc" id="L317">            throw new SystemException(&quot;Unsupported risk control method:&quot; + riskControlMethod);</span>
        }
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L320">            logger.debug(&quot;Determine the final risk control limit of ticket(&quot; + ticket.getSerialNo() + &quot;) as &quot;</span>
                    + finalLimit);
        }
<span class="fc" id="L323">        return finalLimit;</span>
    }

    /**
     * Assemble single selected number based on a entry.
     * 
     * @param entry
     *            The ticket entries.
     * @param kkk
     *            The count of numbers of a single selected-number.
     * @param betOption
     *            The bet option of chance.
     * @return All possible single selected numbers.
     */
    protected List&lt;ChanceOfEntry&gt; assembleSingleSelectedNumbers(BaseEntry entry, int kkk, int betOption) {
<span class="fc" id="L338">        int[] numbers = entry.getParsedSelectedNumber().getBaseNumbers();</span>
        // sort numbers to make sure we always get same selected number even
        // player given in a different order.
<span class="fc" id="L341">        Arrays.sort(numbers);</span>
<span class="fc" id="L342">        Combination c = new Combination(numbers.length, kkk);</span>
<span class="fc" id="L343">        BigDecimal singleEntryAmount = SimpleToolkit.mathDivide(entry.getEntryAmount(), new BigDecimal(c.getTotal()</span>
                .intValue()));
<span class="fc" id="L345">        List&lt;ChanceOfEntry&gt; singleEntries = new ArrayList&lt;ChanceOfEntry&gt;();</span>
<span class="fc" id="L346">        int totalEles = c.getTotal().intValue();</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">        for (int i = 0; i &lt; totalEles; i++) {</span>
<span class="fc" id="L348">            int[] ele = c.getNext();</span>
<span class="fc" id="L349">            StringBuffer selectedNumber = new StringBuffer();</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">            for (int j = 0; j &lt; ele.length; j++) {</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">                if (j != 0) {</span>
<span class="fc" id="L352">                    selectedNumber.append(entry.getParsedSelectedNumber().getNumberDelemeter());</span>
                }
<span class="fc" id="L354">                selectedNumber.append(numbers[ele[j]]);</span>
            }
<span class="fc" id="L356">            singleEntries.add(new ChanceOfEntry(selectedNumber.toString(), singleEntryAmount, betOption));</span>
        }

<span class="fc" id="L359">        return singleEntries;</span>
    }

    public InstantaneousSaleDao getInstantaneousSaleDao() {
<span class="nc" id="L363">        return instantaneousSaleDao;</span>
    }

    public void setInstantaneousSaleDao(InstantaneousSaleDao instantaneousSaleDao) {
<span class="fc" id="L367">        this.instantaneousSaleDao = instantaneousSaleDao;</span>
<span class="fc" id="L368">    }</span>

    public RiskControlLogDao getRiskControlLogDao() {
<span class="fc" id="L371">        return riskControlLogDao;</span>
    }

    public void setRiskControlLogDao(RiskControlLogDao riskControlLogDao) {
<span class="fc" id="L375">        this.riskControlLogDao = riskControlLogDao;</span>
<span class="fc" id="L376">    }</span>

    public RiskControlLogServiceAsyn getRiskControlLogServiceAsyn() {
<span class="fc" id="L379">        return riskControlLogServiceAsyn;</span>
    }

    public void setRiskControlLogServiceAsyn(RiskControlLogServiceAsyn riskControlLogServiceAsyn) {
<span class="fc" id="L383">        this.riskControlLogServiceAsyn = riskControlLogServiceAsyn;</span>
<span class="fc" id="L384">    }</span>

    public EntityManager getEntityManager() {
<span class="nc" id="L387">        return entityManager;</span>
    }

    public void setEntityManager(EntityManager entityManager) {
<span class="nc" id="L391">        this.entityManager = entityManager;</span>
<span class="nc" id="L392">    }</span>

<span class="fc" id="L394">    protected class JsonRiskControlTrans {</span>
<span class="fc" id="L395">        private List&lt;JsonRiskControlTransItem&gt; riskLogs = new LinkedList&lt;JsonRiskControlTransItem&gt;();</span>

        /**
         * As a ticket may contain multiple entries, those multiple entries may maintain the same {@link RiskControlLog}
         * entities, this method will merge those same {@link RiskControlLog} into a single item to avoid repeatedly
         * access same entity when do cancellation.
         */
        public void merge(JsonRiskControlTransItem item) {
<span class="fc" id="L403">            boolean itemExisted = false;</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">            for (JsonRiskControlTransItem existedItem : riskLogs) {</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">                if (existedItem.getId().equalsIgnoreCase(item.getId())) {</span>
<span class="nc" id="L406">                    existedItem.setAmount(existedItem.getAmount().add(item.getAmount()));</span>
<span class="nc" id="L407">                    itemExisted = true;</span>
                }
<span class="fc" id="L409">            }</span>
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">            if (!itemExisted) {</span>
<span class="fc" id="L411">                riskLogs.add(item);</span>
            }
<span class="fc" id="L413">        }</span>

        public List&lt;JsonRiskControlTransItem&gt; getRiskLogs() {
<span class="fc" id="L416">            return riskLogs;</span>
        }
    }

<span class="fc" id="L420">    protected class JsonRiskControlTransItem {</span>
        // id of risk control log
        private String id;
        // amount of the risk control log of current sale transaction.
        private BigDecimal amount;

        public String getId() {
<span class="fc" id="L427">            return id;</span>
        }

        public void setId(String idOfRiskControlLog) {
<span class="fc" id="L431">            this.id = idOfRiskControlLog;</span>
<span class="fc" id="L432">        }</span>

        public BigDecimal getAmount() {
<span class="fc" id="L435">            return amount;</span>
        }

        public void setAmount(BigDecimal betAmount) {
<span class="fc" id="L439">            this.amount = betAmount;</span>
<span class="fc" id="L440">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.2.201302030002</span></div></body></html>