<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CommonFacadeService.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sourcecode</a> &gt; <a href="index.html" class="el_package">com.mpos.lottery.te.port.service</a> &gt; <span class="el_source">CommonFacadeService.java</span></div><h1>CommonFacadeService.java</h1><pre class="source lang-java linenums">package com.mpos.lottery.te.port.service;

import com.mpos.lottery.common.router.NoRoutineFoundException;
import com.mpos.lottery.common.router.RoutineRegistry;
import com.mpos.lottery.common.router.Version;
import com.mpos.lottery.te.common.dao.BaseJpaDao;
import com.mpos.lottery.te.config.MLotteryContext;
import com.mpos.lottery.te.config.dao.SysConfigurationDao;
import com.mpos.lottery.te.config.exception.ApplicationException;
import com.mpos.lottery.te.config.exception.SystemException;
import com.mpos.lottery.te.gamespec.sale.BaseTicket;
import com.mpos.lottery.te.merchant.dao.OperatorMerchantDao;
import com.mpos.lottery.te.merchant.domain.Device;
import com.mpos.lottery.te.merchant.domain.Merchant;
import com.mpos.lottery.te.merchant.domain.Operator;
import com.mpos.lottery.te.merchant.domain.OperatorMerchant;
import com.mpos.lottery.te.port.Context;
import com.mpos.lottery.te.port.domain.router.RoutineKey;
import com.mpos.lottery.te.sequence.service.UUIDService;
import com.mpos.lottery.te.thirdpartyservice.amqp.AmqpMessageUtils;
import com.mpos.lottery.te.thirdpartyservice.amqp.MessagePack;
import com.mpos.lottery.te.trans.dao.SettlementLogItemDao;
import com.mpos.lottery.te.trans.domain.SettlementLog;
import com.mpos.lottery.te.trans.domain.SettlementLogItem;
import com.mpos.lottery.te.trans.domain.Transaction;
import com.mpos.lottery.te.trans.domain.TransactionType;
import com.mpos.lottery.te.trans.service.TransactionService;
import com.mpos.lottery.te.workingkey.service.WorkingKeyService;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.perf4j.StopWatch;
import org.perf4j.commonslog.CommonsLogStopWatch;
import org.springframework.amqp.core.AmqpTemplate;

import java.lang.reflect.InvocationTargetException;
import java.math.BigDecimal;
import java.util.Date;

import javax.annotation.Resource;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

/**
 * The facade of all services. It means client should access service via this facade, due to some common pre-condition,
 * post-condition will be checked here.
 * &lt;p/&gt;
 * It includes:
 * &lt;ol&gt;
 * &lt;li&gt;Does the GPE exists?&lt;/li&gt;
 * &lt;li&gt;Does timestamp in request is between local_timestamp(+/-)10 minutes..middleman-attack&lt;/li&gt;
 * &lt;li&gt;Record transaction&lt;/li&gt;
 * &lt;li&gt;......&lt;/li&gt;
 * &lt;/ol&gt;
 */
<span class="fc" id="L57">public class CommonFacadeService implements FacadeService {</span>
<span class="fc" id="L58">    private Log logger = LogFactory.getLog(CommonFacadeService.class);</span>
    private WorkingKeyService workingKeyService;
    private TransactionService transService;
    private UUIDService uuidManager;
    private BaseJpaDao baseJpaDao;
    private SysConfigurationDao sysConfigurationDao;
    private OperatorMerchantDao operatorMerchantDao;
    @Resource(name = &quot;jpaSettlementLogItemDao&quot;)
    private SettlementLogItemDao settlementLogDao;
    @PersistenceContext
    private EntityManager entityManager;
    private AmqpTemplate amqpTemplate;

    /**
     * A facade method which will accept all incoming requests and route to apropriate service then.
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    public void facade(Context request, Context response) throws ApplicationException {
<span class="fc" id="L76">        this.assembleReponseContext(request, response);</span>

<span class="fc" id="L78">        int transType = request.getTransType();</span>
        // System service
<span class="pc bpc" id="L80" title="1 of 4 branches missed.">        if (transType == TransactionType.GET_WORKING_KEY.getRequestType()</span>
                || transType == TransactionType.CHECK_ALIVE.getRequestType()) {
            // no need to generate transactions
<span class="fc" id="L83">            routeRequest(request, response);</span>
        }
        // merchant service
        else {
            // check operator &amp; merchant
<span class="fc" id="L88">            this.checkOperatorMerchant(request, response);</span>
<span class="fc" id="L89">            this.checkSettlement(response);</span>
            // assemble a transaction
<span class="fc" id="L91">            Transaction trans = this.saveTransaction(request, response);</span>
<span class="fc" id="L92">            request.setTransaction(trans);</span>
<span class="fc" id="L93">            response.setTransaction(trans);</span>

            // dispatch request
<span class="fc" id="L96">            this.routeRequest(request, response);</span>
<span class="fc" id="L97">            this.updateTransaction(response, trans);</span>

            /**
             * Explicitly synchronize the persistence context to the underlying database to avoid false positive.
             * Otherwise there may be risk that publish message successfully while fail to commit transaction due to
             * false positive.
             */
<span class="fc" id="L104">            this.getEntityManager().flush();</span>
<span class="fc" id="L105">            this.publishMessage(request, response);</span>
        }
<span class="fc" id="L107">    }</span>

    // ------------------------------------------------
    // HELPER METHODS
    // ------------------------------------------------

    /**
     * Check whether the operator has performed settlement today. If settlement has been done, no payout allowed that
     * day.
     */
    protected final void checkSettlement(Context&lt;?&gt; respCtx) throws ApplicationException {
<span class="fc" id="L118">        SettlementLogItem settlementLogItem = this.getSettlementLogDao().findByOperator(respCtx.getOperatorId(),</span>
                SettlementLog.STATE_VALID, new Date());
<span class="fc bfc" id="L120" title="All 2 branches covered.">        if (settlementLogItem != null) {</span>
<span class="fc" id="L121">            throw new ApplicationException(SystemException.CODE_NOTRANS_ALLOWED_AFTER_SETTLEMNT, &quot;Operator(id=&quot;</span>
                    + respCtx.getOperatorId() + &quot; has done settlement, no transactions allowed today.&quot;);
        }
<span class="fc" id="L124">    }</span>

    /**
     * WHether the transaction is issued by client automatically. In general those cancellation and reversal should be
     * automatically triggered by client...For those automatical transaction, the backend must guarantee that it should
     * be handled no matter that a operator is removed etc.
     */
    private boolean isAutoTrans(Context request, Context response) throws ApplicationException {
<span class="fc" id="L132">        int reqTransType = request.getTransType();</span>
<span class="fc bfc" id="L133" title="All 4 branches covered.">        if (reqTransType == TransactionType.CANCEL_BY_TRANSACTION.getRequestType()</span>
                || reqTransType == TransactionType.REVERSAL.getRequestType()) {
<span class="fc" id="L135">            return true;</span>
        }
<span class="fc bfc" id="L137" title="All 2 branches covered.">        if (reqTransType == TransactionType.CANCEL_BY_TICKET.getRequestType()) {</span>
<span class="fc" id="L138">            BaseTicket ticket = (BaseTicket) request.getModel();</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">            return !ticket.isManualCancel();</span>
        }
<span class="fc" id="L141">        return false;</span>
    }

    private final void publishMessage(Context request, Context response) {
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">        if (!MLotteryContext.getInstance().getBoolean(&quot;amqp.messagepublish.enable&quot;, false)) {</span>
<span class="nc" id="L146">            logger.debug(&quot;No need to publish transaction message.&quot;);</span>
<span class="nc" id="L147">            return;</span>
        }
<span class="fc" id="L149">        TransactionType reqTransType = TransactionType.getTransactionType(request.getTransType());</span>
<span class="fc" id="L150">        Boolean publishAmqp = (Boolean) response.getProperty(Context.KEY_PUBLISH_AMQP_MESSAGE);</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        if (publishAmqp == null) {</span>
            // by default, we should publish AMQP message.
<span class="fc" id="L153">            publishAmqp = true;</span>
        }
<span class="fc bfc" id="L155" title="All 4 branches covered.">        if (reqTransType.isPublishTransMsg() &amp;&amp; publishAmqp) {</span>
<span class="fc" id="L156">            StopWatch sw = new CommonsLogStopWatch();</span>
<span class="fc" id="L157">            sw.start();</span>
<span class="fc" id="L158">            MessagePack amqpMsg = null;</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">            if (reqTransType.equals(TransactionType.SELL_TICKET)) {</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">                if (response.getTransMessage() == null) {</span>
<span class="fc" id="L161">                    logger.debug(&quot;No sale message found, won't publish.&quot;);</span>
<span class="fc" id="L162">                    return;</span>
                }
                /**
                 * For sale message, keep the original design, otherwise too many consumers have to be amended.
                 */
<span class="fc" id="L167">                amqpMsg = response.getTransMessage();</span>
            } else {
                /**
                 * The new message publishing design...
                 * &lt;p/&gt;
                 * TE will publish a message carrying 'Transaction' entity for sale/payout/topup etc, and corresponding
                 * 'Cancellation' message for 'cancel' transaction. Make a uniform interface, the consumer can retrieve
                 * all information by transaction.
                 */
<span class="fc bfc" id="L176" title="All 2 branches covered.">                if (!reqTransType.isCancellation()) {</span>
                    // publish transaction(the context)
<span class="fc" id="L178">                    amqpMsg = new MessagePack(MessagePack.PREFIX + &quot;.&quot; + request.getTransType(), MessagePack.PREFIX</span>
                            + &quot;.&quot; + request.getTransType() + &quot;.&quot; + request.getGameTypeIdIntValue(),
                            AmqpMessageUtils.assembleTransactionMsg(response));
                } else {
                    /*
                     * publish cancellation to exchange(TE.${OrigialTransType}) with routing key
                     * (TE.CANCEL.${originalTransType}.${gameType})...assemble message in cancelByTransaction service
                     * not all cancellation should be published
                     */
<span class="fc" id="L187">                    amqpMsg = response.getTransMessage();</span>
                }
            }
<span class="fc bfc" id="L190" title="All 2 branches covered.">            if (amqpMsg != null) {</span>
                // set transactionID to header
<span class="fc" id="L192">                amqpMsg.getMessageProperties().setHeader(MessagePack.HEADER_TRANSACTION,</span>
                        response.getTransaction().getId());
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">                if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L195">                    logger.debug(&quot;Prepare to publish message to exchange[&quot; + amqpMsg.getExchangeName()</span>
                            + &quot;] with routing key[&quot; + amqpMsg.getRoutingKey() + &quot;]: &quot; + amqpMsg.getProtobuffMessage());
                }

                /**
                 * As AmqpTemplate will join current transaction context, if rollback the transaction, AmqpTemplate will
                 * send a 'TX.Rollback' to RabbitMQ Broker as well, that result in no consumer will get message.
                 * &lt;p/&gt;
                 * Think about that if you are running integration testcase, it will be rollbacked at the end by
                 * default, so don't expect a message will be published in this case, except you commit the transaction.
                 */
<span class="fc" id="L206">                this.getAmqpTemplate().send(amqpMsg.getExchangeName(), amqpMsg.getRoutingKey(),</span>
                        amqpMsg.getAmqpMessage());
<span class="fc" id="L208">                logger.debug(&quot;Publish message successfully&quot;);</span>
            }
<span class="fc" id="L210">            sw.stop(&quot;finishAMQP&quot;, &quot;Publish AMQP message successfully&quot;);</span>
<span class="fc" id="L211">        } else {</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">            if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L213">                logger.debug(&quot;No need to publish AMQP message of transaction(&quot; + reqTransType + &quot;)&quot;);</span>
            }
        }
<span class="fc" id="L216">    }</span>

    /**
     * Route client request to a appropriate handler. If no handler found by a routine key, its child will be used as
     * key for routing recursively. If no child routine key available, that says no handler registered for the request.
     * 
     * @param request
     *            The request context.
     * @param response
     *            The response context.
     * @throws ApplicationException
     *             The business exception thrown out by handler.
     */
    private void routeRequest(Context request, Context response) throws ApplicationException {
<span class="fc" id="L230">        int gameType = request.getGameTypeIdIntValue();</span>
<span class="fc" id="L231">        RoutineKey routineKey = this.assembleRoutineKey(request, gameType);</span>

        try {
<span class="fc" id="L234">            RoutineKey tmpRoutineKey = routineKey;</span>
            while (true) {
                try {
<span class="fc" id="L237">                    RoutineRegistry.getInstance().route(tmpRoutineKey, new Context[] { request, response });</span>
<span class="fc" id="L238">                    break;</span>
<span class="fc" id="L239">                } catch (NoRoutineFoundException e) {</span>
                    // try lookup handler by child routine key
<span class="fc" id="L241">                    tmpRoutineKey = tmpRoutineKey.child();</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">                    if (tmpRoutineKey == null) {</span>
                        // if control flow reach here, it means no handler
                        // registered for this routine key
<span class="nc" id="L245">                        throw new SystemException(&quot;No controller found by routine key(&quot; + routineKey + &quot;).&quot;);</span>
                    }
<span class="fc" id="L247">                }</span>
            }
<span class="fc" id="L249">        } catch (InvocationTargetException e) {</span>
<span class="fc" id="L250">            Throwable throwable = e.getTargetException();</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">            if (throwable != null) {</span>
                // find the business exception thrown out by handler.
<span class="fc bfc" id="L253" title="All 2 branches covered.">                if (throwable instanceof ApplicationException) {</span>
<span class="fc" id="L254">                    throw (ApplicationException) throwable;</span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">                } else if (throwable instanceof SystemException) {</span>
<span class="fc" id="L256">                    throw (SystemException) throwable;</span>
                } else {
<span class="nc" id="L258">                    throw new SystemException(throwable);</span>
                }
            } else {
<span class="nc" id="L261">                throw new SystemException(e);</span>
            }
<span class="nc" id="L263">        } catch (Exception e) {</span>
<span class="nc" id="L264">            throw new SystemException(e);</span>
<span class="fc" id="L265">        }</span>
<span class="fc" id="L266">    }</span>

    /**
     * Check the preconditions of operator/merchant which must be met before route to service. check below condition: 1)
     * Does the operator exists? 2) Is the operator active?
     */
    protected void checkOperatorMerchant(Context request, Context response) throws ApplicationException {
<span class="fc" id="L273">        boolean isAutoTrans = this.isAutoTrans(request, response);</span>
        // fix bug#4420
        // 1. Verify device... device only need to be allocated to
        // distributor
<span class="fc" id="L277">        Device device = this.getBaseJpaDao().findById(Device.class, request.getTerminalId());</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (device == null) {</span>
<span class="nc" id="L279">            throw new ApplicationException(SystemException.CODE_NO_DEVICE, &quot;The device(id=&quot; + request.getTerminalId()</span>
                    + &quot;) doesn't exist.&quot;);
        }
<span class="fc bfc" id="L282" title="All 2 branches covered.">        if (!isAutoTrans) {</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">            if (device.getMerchant() == null) {</span>
<span class="nc" id="L284">                throw new ApplicationException(SystemException.CODE_NO_ALLOCATED_DEVICE, &quot;device(id=&quot; + device.getId()</span>
                        + &quot; hasn't been allocated to any merchant yet.&quot;);
            }
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">            if (Device.STATUS_ACTIVE != device.getStatus()) {</span>
<span class="nc" id="L288">                throw new ApplicationException(SystemException.CODE_DEVICE_INACTIVE, &quot;device(id=&quot;</span>
                        + request.getTerminalId() + &quot;) is not active.&quot;);
            }
        }
<span class="fc" id="L292">        response.setDevice(device);</span>

        // 2. Verify operator
<span class="fc" id="L295">        String operatorId = request.getOperatorId();</span>
        // check operator'status
<span class="fc" id="L297">        Operator operator = this.getBaseJpaDao().findById(Operator.class, operatorId);</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if (operator == null) {</span>
<span class="nc" id="L299">            throw new ApplicationException(SystemException.CODE_NO_OPERATOR, &quot;operator(id=&quot; + operatorId</span>
                    + &quot;) doesn't exist.&quot;);
        }
<span class="fc bfc" id="L302" title="All 2 branches covered.">        if (!isAutoTrans) {</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">            if (Operator.STATUS_ACTIVE != operator.getStatus()) {</span>
<span class="fc" id="L304">                throw new ApplicationException(SystemException.CODE_OPERATOR_INACTIVE, &quot;operator(id=&quot; + operatorId</span>
                        + &quot;) is not active.&quot;);
            }
            /*
             * if (operator.isNeedEnrollment()) { throw new ApplicationException(SystemException.CODE_NEED_ENROLLMENT,
             * &quot;operator(id=&quot; + operatorId + &quot;) needs to be enrolled first.&quot;); }
             */
        }
<span class="fc" id="L312">        response.setOperator(operator);</span>

        // operator(card) must be assigned to leaf merchant(retailer),
        // however
        // device only needs to be assigned to distributor.
        // lookup the relationship between operator and merchant
<span class="fc" id="L318">        OperatorMerchant operatorMerchant = this.getOperatorMerchantDao().findByOperator(operatorId);</span>
<span class="pc bpc" id="L319" title="1 of 4 branches missed.">        if (!isAutoTrans &amp;&amp; operatorMerchant == null) {</span>
<span class="nc" id="L320">            throw new ApplicationException(SystemException.CODE_OPERATOR_NO_MERCHANT, &quot;operator(id=&quot; + operatorId</span>
                    + &quot;) doesn't belong to any merchant, allocate it first.&quot;);
        }

        // 3. Verify merchant
<span class="fc bfc" id="L325" title="All 2 branches covered.">        if (operatorMerchant != null) {</span>
<span class="fc" id="L326">            Merchant retailer = this.getBaseJpaDao().findById(Merchant.class, operatorMerchant.getMerchantID());</span>
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">            if (retailer == null) {</span>
<span class="nc" id="L328">                throw new ApplicationException(SystemException.CODE_NO_MERCHANT, &quot;merchant(id=&quot;</span>
                        + operatorMerchant.getMerchantID() + &quot;) doesn't exist.&quot;);
            }
<span class="fc bfc" id="L331" title="All 2 branches covered.">            if (!isAutoTrans) {</span>
<span class="fc" id="L332">                retailer.verifyActiveStatusRecursively();</span>
            }
<span class="fc" id="L334">            response.setMerchant(retailer);</span>

            // 4. verify whether device and operator belong to same
            // distributor
<span class="pc bpc" id="L338" title="1 of 4 branches missed.">            if (!isAutoTrans</span>
                    &amp;&amp; device.getMerchant().lookupDistributor().getId() != retailer.lookupDistributor().getId()) {
<span class="nc" id="L340">                throw new ApplicationException(SystemException.CODE_NOT_SAME_MERCHANT, &quot;Device(id=&quot; + device.getId()</span>
                        + &quot;) and operator(id=&quot; + operator.getId() + &quot;) don't belong to same distributor.&quot;);
            }
        }
<span class="fc" id="L344">    }</span>

    /**
     * Assemble a &lt;code&gt;RoutineKey&lt;/code&gt; based on supplied client request.
     */
    protected RoutineKey assembleRoutineKey(Context request, int gameType) {
<span class="fc" id="L350">        return new RoutineKey(gameType, request.getTransType(), Version.from(request.getProtocalVersion()));</span>
    }

    /**
     * Save a transaction before handling business logic.
     * 
     * @param request
     *            The request context.
     * @return a transaction record which represents current transaction.
     */
    private Transaction saveTransaction(Context request, Context response) throws ApplicationException {
        // save transaction
<span class="fc" id="L362">        Transaction trans = new Transaction();</span>
        // guarantee 'x-timestamp' in reponse header can match the time in
        // transaction.createTime
<span class="fc" id="L365">        trans.setCreateTime(response.getTimestamp());</span>
<span class="fc" id="L366">        trans.setDeviceId(request.getTerminalId());</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">        trans.setGpeId(request.getGpe() == null ? null : request.getGpe().getId());</span>
<span class="fc" id="L368">        trans.setId(this.getUuidManager().getGeneralID());</span>
<span class="fc" id="L369">        trans.setOperatorId(request.getOperatorId());</span>
<span class="fc" id="L370">        trans.setTraceMessageId(request.getTraceMessageId());</span>
<span class="fc" id="L371">        trans.setTransTimestamp(request.getTimestamp());</span>
<span class="fc" id="L372">        trans.setType(request.getTransType());</span>
<span class="fc" id="L373">        trans.setBatchNumber(request.getBatchNumber());</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">        if (request.getGpsLocation() != null) {</span>
            // save GPS information...&quot;Longitude,Latitude&quot;
<span class="fc" id="L376">            String[] gps = StringUtils.split(request.getGpsLocation(), &quot;,&quot;);</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">            if (gps.length == 2) {</span>
<span class="fc" id="L378">                trans.setLongitude(new BigDecimal(gps[0]));</span>
<span class="fc" id="L379">                trans.setLatitude(new BigDecimal(gps[1]));</span>
            } else {
<span class="nc" id="L381">                logger.info(&quot;Invalid GPS information(&quot; + request.getGpsLocation() + &quot;), ignore it.&quot;);</span>
            }
        }
        // If is automatical transactions, such as 'cancel by transaction', and
        // the operator hasn't been allocated to any merchant, in this case, the
        // merchant can be null.
<span class="fc bfc" id="L387" title="All 2 branches covered.">        if (response.getMerchant() != null) {</span>
<span class="fc" id="L388">            trans.setMerchantId(response.getMerchant().getId());</span>
<span class="fc" id="L389">            trans.setParentMerchants(response.getMerchant().getParentMerchants());</span>
        }

        /*
         * Transaction instance must be persisted before persisting ticket, or a exception will be thrown: Caused by:
         * java.lang.IllegalStateException: org.hibernate.TransientObjectExcepti on: object references an unsaved
         * transient instance - save the transient instanc e before flushing: com
         * .mpos.lottery.te.gameimpl.lotto.sale.domain.LottoTicket.transaction -&gt; com.m
         * pos.lottery.te.trans.domain.Transaction
         */
        // save transaction
<span class="fc" id="L400">        this.getTransService().save(trans);</span>

<span class="fc" id="L402">        response.setTransactionID(trans.getId());</span>
<span class="fc" id="L403">        return trans;</span>
    }

    /**
     * Update transaction record after handling transaction
     * 
     * @param trans
     *            The transaction instance.
     */
    private void updateTransaction(Context response, Transaction trans) throws ApplicationException {
        // update transaction
<span class="fc" id="L414">        int transType = response.getTransType();</span>
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">        if (transType != TransactionType.GET_WORKING_KEY.getResponseType()) {</span>
            // update transaction
<span class="fc" id="L417">            trans.setResponseCode(response.getResponseCode());</span>
<span class="fc" id="L418">            trans.setUpdateTime(response.getTimestamp());</span>
<span class="fc" id="L419">            this.getTransService().update(trans);</span>
        }
<span class="fc" id="L421">    }</span>

    /**
     * Copy context headers from request to response. Not all headers will be copyed here, and some headers specified to
     * response will be assembled in service layer.
     * 
     * @param request
     *            The request context.
     * @param response
     *            The response context.
     */
    private void assembleReponseContext(Context request, Context response) {
<span class="fc" id="L433">        response.setProtocalVersion(request.getProtocalVersion());</span>
<span class="fc" id="L434">        response.setGpe(request.getGpe());</span>
<span class="fc" id="L435">        response.setOperatorId(request.getOperatorId());</span>
<span class="fc" id="L436">        response.setResponseCode(SystemException.CODE_OK);</span>
<span class="fc" id="L437">        response.setTerminalId(request.getTerminalId());</span>
<span class="fc" id="L438">        response.setBatchNumber(request.getBatchNumber());</span>
<span class="fc" id="L439">        response.setTraceMessageId(request.getTraceMessageId());</span>
<span class="fc" id="L440">        response.setTransType(TransactionType.getTransactionType(request.getTransType()).getResponseType());</span>
<span class="fc" id="L441">        response.setWorkingKey(request.getWorkingKey());</span>
<span class="fc" id="L442">        response.setGameTypeId(request.getGameTypeIdIntValue() + &quot;&quot;);</span>
<span class="fc" id="L443">        response.setTimestamp(new Date());</span>
<span class="fc" id="L444">        response.setGameTypeId(request.getGameTypeId());</span>
<span class="fc" id="L445">        response.setInternalCall(request.isInternalCall());</span>
<span class="fc" id="L446">    }</span>

    // ------------------------------------------------
    // SPRING DEPENDENCIES INJECTION
    // ------------------------------------------------

    public WorkingKeyService getWorkingKeyService() {
<span class="nc" id="L453">        return workingKeyService;</span>
    }

    public void setWorkingKeyService(WorkingKeyService workingKeyService) {
<span class="fc" id="L457">        this.workingKeyService = workingKeyService;</span>
<span class="fc" id="L458">    }</span>

    public TransactionService getTransService() {
<span class="fc" id="L461">        return transService;</span>
    }

    public void setTransService(TransactionService transService) {
<span class="fc" id="L465">        this.transService = transService;</span>
<span class="fc" id="L466">    }</span>

    public UUIDService getUuidManager() {
<span class="fc" id="L469">        return uuidManager;</span>
    }

    public void setUuidManager(UUIDService uuidService) {
<span class="fc" id="L473">        this.uuidManager = uuidService;</span>
<span class="fc" id="L474">    }</span>

    public SysConfigurationDao getSysConfigurationDao() {
<span class="nc" id="L477">        return sysConfigurationDao;</span>
    }

    public void setSysConfigurationDao(SysConfigurationDao sysConfigurationDao) {
<span class="fc" id="L481">        this.sysConfigurationDao = sysConfigurationDao;</span>
<span class="fc" id="L482">    }</span>

    public BaseJpaDao getBaseJpaDao() {
<span class="fc" id="L485">        return baseJpaDao;</span>
    }

    public void setBaseJpaDao(BaseJpaDao baseJpaDao) {
<span class="fc" id="L489">        this.baseJpaDao = baseJpaDao;</span>
<span class="fc" id="L490">    }</span>

    public OperatorMerchantDao getOperatorMerchantDao() {
<span class="fc" id="L493">        return operatorMerchantDao;</span>
    }

    public void setOperatorMerchantDao(OperatorMerchantDao operatorMerchantDao) {
<span class="fc" id="L497">        this.operatorMerchantDao = operatorMerchantDao;</span>
<span class="fc" id="L498">    }</span>

    public EntityManager getEntityManager() {
<span class="fc" id="L501">        return entityManager;</span>
    }

    public void setEntityManager(EntityManager entityManager) {
<span class="nc" id="L505">        this.entityManager = entityManager;</span>
<span class="nc" id="L506">    }</span>

    public AmqpTemplate getAmqpTemplate() {
<span class="fc" id="L509">        return amqpTemplate;</span>
    }

    public void setAmqpTemplate(AmqpTemplate amqpTemplate) {
<span class="fc" id="L513">        this.amqpTemplate = amqpTemplate;</span>
<span class="fc" id="L514">    }</span>

    public SettlementLogItemDao getSettlementLogDao() {
<span class="fc" id="L517">        return settlementLogDao;</span>
    }

    public void setSettlementLogDao(SettlementLogItemDao settlementLogDao) {
<span class="nc" id="L521">        this.settlementLogDao = settlementLogDao;</span>
<span class="nc" id="L522">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.2.201302030002</span></div></body></html>