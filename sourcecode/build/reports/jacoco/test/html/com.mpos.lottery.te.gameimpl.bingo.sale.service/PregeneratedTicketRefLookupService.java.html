<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PregeneratedTicketRefLookupService.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sourcecode</a> &gt; <a href="index.html" class="el_package">com.mpos.lottery.te.gameimpl.bingo.sale.service</a> &gt; <span class="el_source">PregeneratedTicketRefLookupService.java</span></div><h1>PregeneratedTicketRefLookupService.java</h1><pre class="source lang-java linenums">package com.mpos.lottery.te.gameimpl.bingo.sale.service;

import com.mpos.lottery.te.common.dao.BaseEntity;
import com.mpos.lottery.te.common.dao.BaseJpaDao;
import com.mpos.lottery.te.common.util.SimpleToolkit;
import com.mpos.lottery.te.config.exception.ApplicationException;
import com.mpos.lottery.te.config.exception.SystemException;
import com.mpos.lottery.te.gameimpl.bingo.game.BingoFunType;
import com.mpos.lottery.te.gameimpl.bingo.game.BingoGameInstance;
import com.mpos.lottery.te.gameimpl.bingo.sale.BingoEntryRef;
import com.mpos.lottery.te.gameimpl.bingo.sale.BingoTicket;
import com.mpos.lottery.te.gameimpl.bingo.sale.BingoTicketRef;
import com.mpos.lottery.te.gameimpl.bingo.sale.dao.BingoEntryRefDao;
import com.mpos.lottery.te.gameimpl.bingo.sale.dao.BingoTicketRefDao;
import com.mpos.lottery.te.gamespec.game.BaseGameInstance;
import com.mpos.lottery.te.port.Context;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.stereotype.Service;

import java.sql.SQLException;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;
import javax.persistence.EntityManager;
import javax.persistence.LockModeType;
import javax.persistence.PersistenceContext;

/**
 * If player doesn't pick any BINGO numbers, system will pick in-advance generated tickets.
 * 
 * @author Ramon
 */
@Service(&quot;pregeneratedTicketRefLookupService&quot;)
<span class="fc" id="L39">public class PregeneratedTicketRefLookupService implements TicketRefLookupService {</span>
<span class="fc" id="L40">    private static Log logger = LogFactory.getLog(PregeneratedTicketRefLookupService.class);</span>
    @Resource(name = &quot;baseJpaDao&quot;)
    private BaseJpaDao baseJpaDao;
    @Resource(name = &quot;bingoTicketRefDao&quot;)
    private BingoTicketRefDao bingoTicketRefDao;
    @Resource(name = &quot;bingoEntryRefDao&quot;)
    private BingoEntryRefDao bingoEntryRefDao;
    @PersistenceContext
    private EntityManager entityManager;

    /**
     * Lookup a in-advance generated ticket for client. Only those tickets/entries of 'new' status can be picked, and
     * the count of entries must obey the setting of operation parameters, refer to
     * {@link BingoFunType#getMaxEntriesInTicket()}.
     * 
     * @param respCtx
     *            The context of current bingo sale transaction.
     * @param clientTicket
     *            The client sale request. The following components must be assembled by the backend: gameInstance
     * @param pickEntries
     *            Whether need to pick entries for player? As player donesn't have to picker numbers, in this case the
     *            backend will pick those pre-generated numbers automatically.
     * @return A in-advance generated ticket of 'new' status.
     * @throws ApplicationException
     *             if any business exception encountered.
     */
    @Override
    public BingoTicketRef lookupTicket(Context respCtx, BingoTicket clientTicket, boolean pickEntries)
            throws ApplicationException {
        // lookup a new ticket first
<span class="fc" id="L70">        BingoTicketRef ticketRef = this.lockTicket(respCtx, clientTicket);</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L72">            logger.debug(&quot;Locked referenced ticket(id=&quot; + ticketRef.getId() + &quot;,serialNo=&quot;</span>
                    + ticketRef.getImportTicketSerialNo() + &quot;) successfully.&quot;);
        }

<span class="fc bfc" id="L76" title="All 2 branches covered.">        if (pickEntries) {</span>
            // lookup 'new' entries then
<span class="fc" id="L78">            List&lt;BaseEntity&gt; entries = this.lockEntries(respCtx, clientTicket);</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">            for (BaseEntity entry : entries) {</span>
<span class="fc" id="L80">                BingoEntryRef entryRef = (BingoEntryRef) entry;</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">                if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L82">                    logger.debug(&quot;Lock referenced entry(id=&quot; + entryRef.getId() + &quot;,selectedNumber:&quot;</span>
                            + entryRef.getSelectedNumber() + &quot;) successfully.&quot;);
                }
<span class="fc" id="L85">                ticketRef.getEntryRefs().add(entryRef);</span>
<span class="fc" id="L86">            }</span>
        }

<span class="fc" id="L89">        return ticketRef;</span>
    }

    /**
     * Lock a new {@code BingoTicketRef}. As service is under concurrent access, we must ensure that a ticket can be
     * only sold to a single player.
     * &lt;p/&gt;
     * If fail to lock a entity of {@code BingoTicketRef}, the next entity will be tried immediately, and will continue
     * this process until reach the last available entity or lock a entity successfully. By locking a entity, we ensure
     * that no other threads can get the same entity instantaneously.
     */
    protected BingoTicketRef lockTicket(Context respCtx, BingoTicket clientTicket) throws ApplicationException {
<span class="fc" id="L101">        BingoGameInstance gameInstance = (BingoGameInstance) clientTicket.getGameInstance();</span>

        // lock game instance first
<span class="fc" id="L104">        this.getEntityManager().lock(gameInstance, LockModeType.PESSIMISTIC_READ);</span>

<span class="fc" id="L106">        BingoTicketRef ticketRef = this.getBingoTicketRefDao().findByGameInstanceAndSequence(gameInstance.getId(),</span>
                gameInstance.getCurrentSequence());
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">        if (ticketRef == null) {</span>
<span class="nc" id="L109">            throw new SystemException(&quot;No entity(&quot; + BingoTicketRef.class + &quot;) found by gameInstanceId=&quot;</span>
                    + gameInstance.getId() + &quot;,currentSequence=&quot; + gameInstance.getCurrentSequence());
        }

        // update current sequence
<span class="fc" id="L114">        gameInstance.setCurrentSequence(gameInstance.getCurrentSequence() + 1);</span>

<span class="fc" id="L116">        return ticketRef;</span>
    }

    /**
     * Lookup 'new' referenced bingo entries. Refer to {@link #lockTicket(Context, BingoTicket)} for concurrent access
     * restriction.
     */
    protected List&lt;BaseEntity&gt; lockEntries(Context respCtx, BingoTicket clientTicket) throws ApplicationException {
<span class="fc" id="L124">        BaseGameInstance gameInstance = clientTicket.getGameInstance();</span>
<span class="fc" id="L125">        BingoFunType bingoFunType = this.getBaseJpaDao().findById(BingoFunType.class,</span>
                gameInstance.getGame().getFunTypeId());

<span class="fc" id="L128">        int countOfLock = bingoFunType.getMaxEntriesInTicket();</span>
        // lookup all ticket of new status
<span class="fc" id="L130">        List&lt;BingoEntryRef&gt; entryRefs = this.getBingoEntryRefDao().findByGameInstanceAndState(gameInstance.getId(),</span>
                BingoTicketRef.STATUS_NEW);
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (entryRefs.size() &lt; countOfLock) {</span>
<span class="nc" id="L133">            throw new ApplicationException(SystemException.CODE_NO_ENOUGH_REF_ENTRY,</span>
                    &quot;No 'new' reference entry found of given game instance(id=&quot; + gameInstance.getId() + &quot;), expected:&quot;
                            + countOfLock + &quot;, actual:&quot; + entryRefs.size());
        }

<span class="fc" id="L138">        List&lt;BaseEntity&gt; locks = this.lock(entryRefs, countOfLock);</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        if (locks.size() &lt; countOfLock) {</span>
<span class="nc" id="L140">            throw new ApplicationException(SystemException.CODE_NO_ENOUGH_REF_ENTRY,</span>
                    &quot;No enough 'new' reference entry found of given game instance(id=&quot; + gameInstance.getId()
                            + &quot;), expected:&quot; + countOfLock + &quot;, actual:&quot; + locks.size() + &quot;, however total &quot;
                            + (entryRefs.size() - locks.size()) + &quot; have been locked by other players.&quot;);
        }
<span class="fc" id="L145">        return locks;</span>
    }

    protected List&lt;BaseEntity&gt; lock(List&lt;? extends BaseEntity&gt; entities, int countOfLock) {
<span class="fc" id="L149">        Map&lt;String, Object&gt; hints = new HashMap&lt;String, Object&gt;();</span>
        /**
         * Regarding what standard hints properties are supported, refer to &quot;#3.4.4.3 Lock Mode Properties and Use&quot; of
         * JPA2.1 specification document.
         * &lt;p/&gt;
         * If no hint 'javax.persistence.lock.timeout' supplied, the underlying SQL will be:
         * &lt;p/&gt;
         * select ID from XX where ID =111 for update
         * &lt;p/&gt;
         * If provide this hint and set value to 0, the SQL will be:
         * &lt;p/&gt;
         * select ID from XX where ID =111 for update for update nowait
         * &lt;p/&gt;
         * If provide this hint and set a value which is greater than 0(the measurement unit for hint is millisecond,
         * however it is second in SQL, that says if your provide hint with value 10 milliseconds, the SQL will tell you
         * wait 0 seconds ), the SQL will be:
         * &lt;p/&gt;
         * select ID from XX where ID =111 for update for update wait XX
         * &lt;p/&gt;
         */
<span class="fc" id="L169">        hints.put(&quot;javax.persistence.lock.timeout&quot;, 0);</span>
<span class="fc" id="L170">        List&lt;BaseEntity&gt; locks = new LinkedList&lt;BaseEntity&gt;();</span>
<span class="fc" id="L171">        int index = 0;</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">        for (BaseEntity entity : entities) {</span>
            // check whether the entity is managed first.
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">            if (!this.getEntityManager().contains(entity)) {</span>
<span class="nc" id="L175">                throw new SystemException(&quot;Entity(&quot; + entity + &quot;,id=&quot; + entity.getId()</span>
                        + &quot;) isn't managed, can't be locked.&quot;);
            }
            try {
<span class="fc" id="L179">                this.getEntityManager().lock(entity, LockModeType.PESSIMISTIC_READ, hints);</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">                if (index &lt; countOfLock) {</span>
<span class="fc" id="L181">                    locks.add(entity);</span>
<span class="fc" id="L182">                    index++;</span>
                } else {
                    // got enough locked entities successfully, break then
<span class="fc" id="L185">                    break;</span>
                }
<span class="nc" id="L187">            } catch (Exception e) {</span>
<span class="nc" id="L188">                Throwable rootCause = SimpleToolkit.getRootCause(e);</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                if (rootCause instanceof SQLException) {</span>
<span class="nc" id="L190">                    SQLException sqlRoot = (SQLException) rootCause;</span>
                    // ORA-00054: resource busy and acquire with NOWAIT
                    // specified or timeout expired
<span class="nc bnc" id="L193" title="All 2 branches missed.">                    if (54 == sqlRoot.getErrorCode()) {</span>
<span class="nc" id="L194">                        logger.warn(&quot;Entity(&quot; + entity + &quot;,id=&quot; + entity.getId()</span>
                                + &quot;) has been locked by other threads, will try other entitiy.&quot;);
<span class="nc" id="L196">                        continue;</span>
                    }
                }

                // throwout any other exception
<span class="nc" id="L201">                throw new SystemException(e);</span>
<span class="fc" id="L202">            }</span>
<span class="fc" id="L203">        }</span>

<span class="fc" id="L205">        return locks;</span>
    }

    // ----------------------------------------------------------------
    // SPRING DEPENDENCIES INJECTION
    // ----------------------------------------------------------------

    public BaseJpaDao getBaseJpaDao() {
<span class="fc" id="L213">        return baseJpaDao;</span>
    }

    public void setBaseJpaDao(BaseJpaDao baseJpaDao) {
<span class="nc" id="L217">        this.baseJpaDao = baseJpaDao;</span>
<span class="nc" id="L218">    }</span>

    public BingoTicketRefDao getBingoTicketRefDao() {
<span class="fc" id="L221">        return bingoTicketRefDao;</span>
    }

    public void setBingoTicketRefDao(BingoTicketRefDao bingoTicketRefDao) {
<span class="nc" id="L225">        this.bingoTicketRefDao = bingoTicketRefDao;</span>
<span class="nc" id="L226">    }</span>

    public BingoEntryRefDao getBingoEntryRefDao() {
<span class="fc" id="L229">        return bingoEntryRefDao;</span>
    }

    public void setBingoEntryRefDao(BingoEntryRefDao bingoEntryRefDao) {
<span class="nc" id="L233">        this.bingoEntryRefDao = bingoEntryRefDao;</span>
<span class="nc" id="L234">    }</span>

    public EntityManager getEntityManager() {
<span class="fc" id="L237">        return entityManager;</span>
    }

    public void setEntityManager(EntityManager entityManager) {
<span class="nc" id="L241">        this.entityManager = entityManager;</span>
<span class="nc" id="L242">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.2.201302030002</span></div></body></html>