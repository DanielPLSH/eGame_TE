<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractPrizeService.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sourcecode</a> &gt; <a href="index.html" class="el_package">com.mpos.lottery.te.gamespec.prize.service.impl</a> &gt; <span class="el_source">AbstractPrizeService.java</span></div><h1>AbstractPrizeService.java</h1><pre class="source lang-java linenums">package com.mpos.lottery.te.gamespec.prize.service.impl;

import com.google.gson.Gson;

import com.mpos.lottery.te.common.dao.BaseJpaDao;
import com.mpos.lottery.te.common.util.SimpleToolkit;
import com.mpos.lottery.te.config.MLotteryContext;
import com.mpos.lottery.te.config.exception.ApplicationException;
import com.mpos.lottery.te.config.exception.SystemException;
import com.mpos.lottery.te.gamespec.game.BaseGameInstance;
import com.mpos.lottery.te.gamespec.game.BaseOperationParameter;
import com.mpos.lottery.te.gamespec.game.Game;
import com.mpos.lottery.te.gamespec.game.GameType;
import com.mpos.lottery.te.gamespec.game.service.GameInstanceService;
import com.mpos.lottery.te.gamespec.prize.BasePrizeObject;
import com.mpos.lottery.te.gamespec.prize.BaseWinningItem;
import com.mpos.lottery.te.gamespec.prize.PrizeGroupItem;
import com.mpos.lottery.te.gamespec.prize.PrizeLevel;
import com.mpos.lottery.te.gamespec.prize.PrizeLevelItem;
import com.mpos.lottery.te.gamespec.prize.dao.BaseWinningItemDao;
import com.mpos.lottery.te.gamespec.prize.dao.BaseWinningStatisticsDao;
import com.mpos.lottery.te.gamespec.prize.dao.PrizeLevelDao;
import com.mpos.lottery.te.gamespec.prize.service.PrizeService;
import com.mpos.lottery.te.gamespec.prize.service.TaxService;
import com.mpos.lottery.te.gamespec.prize.support.luckydraw.LuckyDrawWinningItem;
import com.mpos.lottery.te.gamespec.prize.support.luckydraw.LuckyGameInstance;
import com.mpos.lottery.te.gamespec.prize.support.payoutstrategy.PayoutStrategy;
import com.mpos.lottery.te.gamespec.prize.support.payoutstrategy.PayoutStrategyFactory;
import com.mpos.lottery.te.gamespec.prize.web.PrizeAmount;
import com.mpos.lottery.te.gamespec.prize.web.PrizeDto;
import com.mpos.lottery.te.gamespec.prize.web.PrizeItemDto;
import com.mpos.lottery.te.gamespec.prize.web.PrizeLevelItemDto;
import com.mpos.lottery.te.gamespec.prize.web.PrizeLevelObjectItemDto;
import com.mpos.lottery.te.gamespec.sale.BaseEntry;
import com.mpos.lottery.te.gamespec.sale.BaseTicket;
import com.mpos.lottery.te.gamespec.sale.dao.BaseEntryDao;
import com.mpos.lottery.te.gamespec.sale.dao.BaseTicketDao;
import com.mpos.lottery.te.merchant.dao.BalanceTransactionsDao;
import com.mpos.lottery.te.merchant.domain.BalanceTransactions;
import com.mpos.lottery.te.merchant.domain.Merchant;
import com.mpos.lottery.te.merchant.service.CreditService;
import com.mpos.lottery.te.merchant.service.MerchantService;
import com.mpos.lottery.te.merchant.web.PayoutLevelAllowRequest;
import com.mpos.lottery.te.port.Context;
import com.mpos.lottery.te.port.domain.router.RoutineKey;
import com.mpos.lottery.te.trans.domain.Transaction;
import com.mpos.lottery.te.trans.domain.TransactionType;
import com.mpos.lottery.te.trans.domain.logic.AbstractReversalOrCancelStrategy;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.perf4j.StopWatch;
import org.perf4j.log4j.Log4JStopWatch;
import org.springframework.dao.DataIntegrityViolationException;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;

<span class="fc" id="L67">public abstract class AbstractPrizeService extends AbstractReversalOrCancelStrategy implements PrizeService {</span>
<span class="fc" id="L68">    private Log logger = LogFactory.getLog(AbstractPrizeService.class);</span>
    // Spring dependencies
    private BaseTicketDao baseTicketDao;
    private BaseEntryDao baseEntryDao;
    private GameInstanceService gameInstanceService;
    private CreditService creditService;
    private MerchantService merchantService;
    private BaseJpaDao baseJpaDao;
    private BaseWinningItemDao baseWinningItemDao;
    private BaseWinningStatisticsDao baseWinningStatisticsDao;
    private TaxService taxService;
    private PayoutStrategyFactory payoutStrategyFactory;
    private PrizeLevelDao prizeLevelDao;
    @Resource(name = &quot;balanceTransactionsDao&quot;)
    private BalanceTransactionsDao balanceTransactionsDao;

    /**
     * @see com.mpos.lottery.te.trans.domain.logic.ReversalOrCancelStrategy#supportedReversalRoutineKey() .
     */
    public RoutineKey supportedReversalRoutineKey() {
<span class="fc" id="L88">        return new RoutineKey(this.supportedGameType().getType(), TransactionType.PAYOUT.getRequestType(), null);</span>
    }

    @Override
    public final PrizeDto enquiry(Context&lt;?&gt; respCtx, BaseTicket clientTicket) throws ApplicationException {
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L94">            logger.debug(&quot;Enquiry prize information of ticket:&quot; + clientTicket.getSerialNo());</span>
        }
<span class="fc" id="L96">        List&lt;? extends BaseTicket&gt; hostTickets = this.lookupTickets(clientTicket.getSerialNo());</span>

<span class="fc" id="L98">        BaseTicket soldTicket = hostTickets.get(0);</span>
<span class="fc" id="L99">        BaseGameInstance soldGameInstance = soldTicket.getGameInstance();</span>

        // check whether game instance are ready for payout
<span class="fc" id="L102">        this.getGameInstanceService().allowPayout(respCtx, hostTickets, true);</span>
        // check whether ticket is allowed for payout
<span class="fc" id="L104">        soldTicket.allowPayout(respCtx, clientTicket, true, this.lookupTicketEntriess(soldTicket.getSerialNo()));</span>
<span class="fc" id="L105">        this.determineWinningStatus(clientTicket, hostTickets);</span>

        // calculate PrizeDto
<span class="fc" id="L108">        PrizeDto prize = this.assemblePrize(respCtx, clientTicket, hostTickets, true);</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (BaseOperationParameter.PAYOUTMODE_PRINTNEWTICKET == prize.getPayoutMode()) {</span>
<span class="fc" id="L110">            prize.setReturnAmount(null);</span>
        }

        // Tell client whether PIN verification will be preocessed when payout.
<span class="fc bfc" id="L114" title="All 2 branches covered.">        if (!soldTicket.getPIN().equals(MLotteryContext.getInstance().getIgnoredPIN())) {</span>
<span class="fc" id="L115">            prize.setVerifyPIN(true);</span>
        }
        // update transaction
<span class="fc" id="L118">        respCtx.getTransaction().setGameId(soldGameInstance.getGame().getId());</span>
<span class="fc" id="L119">        respCtx.getTransaction().setTotalAmount(prize.getActualAmount());</span>
<span class="fc" id="L120">        respCtx.getTransaction().setTicketSerialNo(soldTicket.getSerialNo());</span>

<span class="fc" id="L122">        return prize;</span>
    }

    @Override
    public final PrizeDto payout(Context&lt;?&gt; respCtx, BaseTicket clientTicket) throws ApplicationException {
<span class="fc" id="L127">        List&lt;? extends BaseTicket&gt; hostTickets = this.lookupTickets(clientTicket.getSerialNo());</span>
<span class="fc" id="L128">        this.determineWinningStatus(clientTicket, hostTickets);</span>

<span class="fc" id="L130">        BaseTicket soldTicket = hostTickets.get(0);</span>
<span class="fc" id="L131">        BaseGameInstance soldGameInstance = soldTicket.getGameInstance();</span>
        // check whether game instance are ready for payout
<span class="fc" id="L133">        this.getGameInstanceService().allowPayout(respCtx, hostTickets, false);</span>
        // check whether ticket is allowed for payout
<span class="fc" id="L135">        soldTicket.allowPayout(respCtx, clientTicket, false, this.lookupTicketEntriess(soldTicket.getSerialNo()));</span>
        // check whether the distributor of sale and payout is same
<span class="fc" id="L137">        this.checkDistributor(soldTicket.getTransaction(), respCtx.getTransaction());</span>

<span class="fc" id="L139">        PrizeDto prize = this.assemblePrize(respCtx, clientTicket, hostTickets, false);</span>

<span class="fc" id="L141">        BigDecimal totalAmount = prize.getActualAmount();</span>
<span class="pc bpc" id="L142" title="1 of 4 branches missed.">        if (prize.getReturnAmount() != null</span>
                &amp;&amp; BaseOperationParameter.PAYOUTMODE_PRINTNEWTICKET == prize.getPayoutMode()) {
            /**
             * Consider below case:
             * &lt;p/&gt;
             * a player buy multiple-draw ticket(3 advanced draw), and the first draw is closed, and the ticket win
             * nothing, the player come to claim prize, for sure system should print new ticket successfully. In this
             * case the actual amount is 0, if we don't count return amount, a exception &quot;isn't a winning ticket&quot; will
             * be thrown out.
             */
<span class="fc" id="L152">            totalAmount = totalAmount.add(prize.getReturnAmount());</span>
            // shouldn't response return amount to client.
<span class="fc" id="L154">            prize.setReturnAmount(null);</span>
        }
        // lucky amount won't be counted into prize amount.
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        if ((totalAmount.add(prize.getLuckyPrizeAmount())).compareTo(new BigDecimal(&quot;0&quot;)) == 0) {</span>
<span class="nc" id="L158">            throw new ApplicationException(SystemException.CODE_NOTWINNINGTICKET, &quot;Ticket(serialNo=&quot;</span>
                    + clientTicket.getSerialNo() + &quot;) isn't a winning ticket.&quot;);
        }

        // check max payout amount of merchant
<span class="fc" id="L163">        this.getMerchantService().allowPayout(respCtx, soldTicket.getGameInstance().getGame(),</span>
                this.assemblePayoutLevelAllowRequests(respCtx, prize, prize.getWinningTicket()),
                prize.getActualAmount());

        // apply Payout Strategy
<span class="fc" id="L168">        PayoutStrategy strategy = this.getPayoutStrategyFactory().lookupPayoutStrategy(prize.getPayoutMode());</span>
<span class="fc" id="L169">        strategy.payout(respCtx, this.supportedGameType(), prize, hostTickets);</span>

        // update transactio

<span class="fc" id="L173">        respCtx.getTransaction().setGameId(soldGameInstance.getGame().getId());</span>
<span class="fc" id="L174">        respCtx.getTransaction().setTotalAmount(prize.getActualAmount());</span>
<span class="fc" id="L175">        respCtx.getTransaction().setTicketSerialNo(soldTicket.getSerialNo());</span>

        // restore credit
        // update credit level of merchant
<span class="fc" id="L179">        BigDecimal creditAmount = prize.getActualAmount();</span>
        // retrieve game identifier
<span class="fc" id="L181">        Object updatedOperator = this.getCreditService().credit(respCtx.getTransaction().getOperatorId(),</span>
                respCtx.getTransaction().getMerchantId(), creditAmount, soldGameInstance.getGame().getId(), true,
                false, false, respCtx.getTransaction());
        // 鏄惁瑷堢畻鍌噾
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        if (MLotteryContext.getInstance().getSysConfiguration().isSupportCommissionCalculation()) {</span>
<span class="fc" id="L186">            BalanceTransactions tempBalanceTransactions = new Gson().fromJson(respCtx.getTransaction()</span>
                    .getTransMessage().getRequestMsg(), BalanceTransactions.class);
<span class="fc" id="L188">            BalanceTransactions operatorBalanceTransactions = balanceTransactionsDao.assembleBalanceTransactions(</span>
                    respCtx, creditAmount);
<span class="fc" id="L190">            operatorBalanceTransactions.setGameId(soldGameInstance.getGameId());</span>
<span class="fc" id="L191">            operatorBalanceTransactions.setCommissionAmount(tempBalanceTransactions.getCommissionAmount());</span>
<span class="fc" id="L192">            operatorBalanceTransactions.setCommissionRate(tempBalanceTransactions.getCommissionRate());</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">            if (updatedOperator == null) {</span>
<span class="nc" id="L194">                throw new SystemException(SystemException.CODE_OPERATOR_TOPUP_IGNORED, &quot;THe payout to operator(id=&quot;</span>
                        + respCtx.getOperatorId() + &quot; will be ignored.&quot;);
            } else {
<span class="fc bfc" id="L197" title="All 2 branches covered.">                if (updatedOperator instanceof Merchant) {</span>
<span class="fc" id="L198">                    Merchant merchant = (Merchant) updatedOperator;</span>
<span class="fc" id="L199">                    BalanceTransactions merchantBalanceTransactions = balanceTransactionsDao</span>
                            .assembleBalanceTransactions(respCtx, creditAmount);
<span class="fc" id="L201">                    merchantBalanceTransactions.setOwnerId(String.valueOf(merchant.getId()));</span>
<span class="fc" id="L202">                    merchantBalanceTransactions.setOwnerType(BalanceTransactions.OWNER_TYPE_MERCHANT);</span>
<span class="fc" id="L203">                    balanceTransactionsDao.insert(merchantBalanceTransactions);</span>
                }
            }
<span class="fc" id="L206">            balanceTransactionsDao.insert(operatorBalanceTransactions);</span>
        }
<span class="fc" id="L208">        return prize;</span>
    }

    @Override
    public final void confirmPayout(Context&lt;?&gt; respCtx, BaseTicket clientTicket) throws ApplicationException {
<span class="fc" id="L213">        List&lt;? extends BaseTicket&gt; hostTickets = this.lookupTickets(clientTicket.getSerialNo());</span>
<span class="fc" id="L214">        BaseOperationParameter opParam = this.lookupOperationParameter(hostTickets.get(0).getGameInstance().getGame());</span>

        // apply Payout Strategy
<span class="fc" id="L217">        PayoutStrategy strategy = this.getPayoutStrategyFactory().lookupPayoutStrategy(opParam.getPayoutMode());</span>
<span class="fc" id="L218">        strategy.confirm(respCtx, this.supportedGameType(), hostTickets);</span>
<span class="fc" id="L219">    }</span>

    @Override
    public final boolean cancelOrReverse(Context&lt;?&gt; respCtx, Transaction targetTrans) throws ApplicationException {
        // restore the status of multiple-draw ticket, or the winning analysis
        // process will ignore these tickets.
<span class="fc" id="L225">        String ticketSerialNo = targetTrans.getTicketSerialNo();</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">        if (ticketSerialNo == null) {</span>
<span class="nc" id="L227">            throw new SystemException(&quot;transacion(payout).ticketserialNo can NOT be null&quot;);</span>
        }
        // apply Payout reversal Strategy
<span class="fc" id="L230">        List&lt;? extends BaseTicket&gt; hostTickets = this.lookupTickets(ticketSerialNo);</span>
<span class="fc" id="L231">        BaseOperationParameter opParam = this.lookupOperationParameter(hostTickets.get(0).getGameInstance().getGame());</span>
<span class="fc" id="L232">        PayoutStrategy strategy = this.getPayoutStrategyFactory().lookupPayoutStrategy(opParam.getPayoutMode());</span>
<span class="fc" id="L233">        strategy.reverse(respCtx, this.supportedGameType(), hostTickets, targetTrans);</span>

        // restore credit level
<span class="fc" id="L236">        this.getCreditService().credit(targetTrans.getOperatorId(), targetTrans.getMerchantId(),</span>
                targetTrans.getTotalAmount(), hostTickets.get(0).getGameInstance().getGame().getId(), false, false,
                false, targetTrans);

<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        if (MLotteryContext.getInstance().getSysConfiguration().isSupportCommissionCalculation()) {</span>
            // cancelled balance transaction
<span class="fc" id="L242">            BalanceTransactions tempBalanceTransactions = new Gson().fromJson(targetTrans.getTransMessage()</span>
                    .getRequestMsg(), BalanceTransactions.class);
<span class="fc" id="L244">            BalanceTransactions operatorBalanceTransactions = balanceTransactionsDao.assembleBalanceTransactions(</span>
                    respCtx, tempBalanceTransactions.getTransactionAmount());
<span class="fc" id="L246">            operatorBalanceTransactions.setOriginalTransType(targetTrans.getType());</span>
<span class="fc" id="L247">            operatorBalanceTransactions.setCommissionAmount(BalanceTransactions.ZERO.subtract(tempBalanceTransactions</span>
                    .getCommissionAmount()));
<span class="fc" id="L249">            operatorBalanceTransactions.setTransactionAmount(tempBalanceTransactions.getTransactionAmount());</span>
<span class="fc" id="L250">            operatorBalanceTransactions.setCommissionRate(tempBalanceTransactions.getCommissionRate());</span>
<span class="fc" id="L251">            balanceTransactionsDao.updateBalanceTransactionsStatusByteTransactionId(targetTrans.getTransMessage()</span>
                    .getTransactionId());
<span class="fc" id="L253">            balanceTransactionsDao.insert(operatorBalanceTransactions);</span>
        }

<span class="fc" id="L256">        return false;</span>
    }

    // -----------------------------------------------------------------------
    // HELPER METHODS
    // -----------------------------------------------------------------------

    /**
     * Check whether the distributor of retailer which sold a ticket allows the tickets to claim prize at other
     * distributor.
     */
    private void checkDistributor(Transaction saleTrans, Transaction payoutTrans) throws ApplicationException {
<span class="fc" id="L268">        Merchant saleDistributor = this.getMerchantService().getMerchant(saleTrans.getMerchantId()).lookupDistributor();</span>
<span class="pc bpc" id="L269" title="2 of 4 branches missed.">        if (saleDistributor != null &amp;&amp; saleDistributor.isSalePayoutUnderSameDistributor()) {</span>
<span class="nc" id="L270">            Merchant payoutDistributor = this.getMerchantService().getMerchant(payoutTrans.getMerchantId())</span>
                    .lookupDistributor();
<span class="nc bnc" id="L272" title="All 4 branches missed.">            if (payoutDistributor != null &amp;&amp; saleDistributor.getId() == payoutDistributor.getId()) {</span>
                // they are under same distributor
            } else {
<span class="nc" id="L275">                throw new ApplicationException(SystemException.CODE_SALE_PAYOUT_DIFF_DISTRIBUTOR,</span>
                        &quot;The distributor of sale is &quot; + saleDistributor.getId()
                                + &quot; isn't same with distributor of payout &quot; + payoutDistributor.getId());
            }
        }
<span class="fc" id="L280">    }</span>

    protected PayoutLevelAllowRequest[] assemblePayoutLevelAllowRequests(Context&lt;?&gt; respCtx, PrizeDto prize,
            BaseTicket ticket) {
        // key is the draw type, such as normal draw, lucky draw etc.
<span class="fc" id="L285">        Map&lt;String, PayoutLevelAllowRequest&gt; levelRequestMap = new HashMap&lt;String, PayoutLevelAllowRequest&gt;();</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">        for (PrizeItemDto prizeItem : prize.getPrizeItems()) {</span>
<span class="fc" id="L287">            PayoutLevelAllowRequest levelRequest = levelRequestMap.get(prizeItem.getType() + &quot;&quot;);</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">            if (levelRequest == null) {</span>
<span class="fc" id="L289">                int gameType = ticket.getGameInstance().getGame().getType();</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">                if (PrizeGroupItem.GROUP_TYPE_GLOBAL_LUCKYDRAW == prizeItem.getType()) {</span>
                    // for lucky draw, the game type will be fixed.
<span class="fc" id="L292">                    gameType = GameType.LUCKYDRAW.getType();</span>
                }
<span class="fc" id="L294">                levelRequest = new PayoutLevelAllowRequest(new HashSet&lt;Integer&gt;(), gameType, prizeItem.getType());</span>
<span class="fc" id="L295">                levelRequestMap.put(prizeItem.getType() + &quot;&quot;, levelRequest);</span>
            }
<span class="fc bfc" id="L297" title="All 2 branches covered.">            for (PrizeLevelItemDto w : prizeItem.getPrizeLevelItems()) {</span>
<span class="fc" id="L298">                levelRequest.getRequestedPrizeLevels().add(Integer.parseInt(w.getPrizeLevel()));</span>
<span class="fc" id="L299">            }</span>
<span class="fc" id="L300">        }</span>
<span class="fc" id="L301">        PayoutLevelAllowRequest[] reqs = new PayoutLevelAllowRequest[levelRequestMap.values().size()];</span>
<span class="fc" id="L302">        levelRequestMap.values().toArray(reqs);</span>
<span class="fc" id="L303">        return reqs;</span>
    }

    /**
     * Calculate prize information of a given ticket.
     */
    protected PrizeDto assemblePrize(Context&lt;?&gt; respCtx, BaseTicket clientTicket,
            List&lt;? extends BaseTicket&gt; hostTickets, boolean isPrizeEnquiry) throws ApplicationException {
<span class="fc" id="L311">        BaseTicket soldTicket = hostTickets.get(0);</span>
        // initial PrizeDto
<span class="fc" id="L313">        PrizeDto prize = this.newPrize(clientTicket, hostTickets);</span>

        // ** Handle normal draw
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        if (clientTicket.isWinning()) {</span>
<span class="fc" id="L317">            StopWatch sw = new Log4JStopWatch();</span>
            // handle ticket one by one, that says one game instance by one game
            // instance
<span class="fc bfc" id="L320" title="All 2 branches covered.">            for (BaseTicket t : hostTickets) {</span>
                // only need to check the payout-started game instance
<span class="fc bfc" id="L322" title="All 2 branches covered.">                if (BaseGameInstance.STATE_PAYOUT_STARTED == t.getGameInstance().getState()) {</span>
<span class="fc" id="L323">                    prize.getPaidTickets().add(t);</span>
                    // assemble normal prize information
<span class="fc" id="L325">                    List&lt;? extends BaseWinningItem&gt; winningItems = this.lookupWinningItem(t.getGameInstance().getId(),</span>
                            soldTicket.getSerialNo(), t.getGameInstance().getVersion());
<span class="fc bfc" id="L327" title="All 2 branches covered.">                    if (winningItems.size() == 0) {</span>
<span class="fc" id="L328">                        continue;</span>
                    }

<span class="fc" id="L331">                    PrizeItemDto prizeItem = new PrizeItemDto();</span>
<span class="fc" id="L332">                    prizeItem.setGameInstance(t.getGameInstance());</span>
<span class="fc" id="L333">                    prizeItem.getGameInstance().setGameId(t.getGameInstance().getGame().getId());</span>
<span class="fc" id="L334">                    prizeItem.setType(PrizeGroupItem.GROUP_TYPE_NORMAL_DRAW);</span>
<span class="fc" id="L335">                    prize.addPrizeItem(prizeItem);</span>
<span class="fc" id="L336">                    this.assembleNormalPrizeItem(prize, prizeItem, t, winningItems);</span>

                    // if calculate tax per ticket, do it here
<span class="fc" id="L339">                    this.calculateTaxBasedOnPerTicket(prize, t, prizeItem);</span>
<span class="fc" id="L340">                } else {</span>
                    // regard it as 'return'
<span class="fc" id="L342">                    prize.setReturnAmount(prize.getReturnAmount().add(t.getTotalAmount()));</span>
<span class="fc" id="L343">                    prize.getFutureTickets().add(t);</span>
                }
<span class="fc" id="L345">            }</span>
<span class="fc" id="L346">            sw.stop(&quot;Assemble_Normal_Prize&quot;, &quot;Assemble normal draw prize of ticket(&quot; + clientTicket.getSerialNo() + &quot;)&quot;);</span>
        }

        // ** handle lucky draw
<span class="fc bfc" id="L350" title="All 2 branches covered.">        if (clientTicket.isLuckyWinning()) {</span>
<span class="fc" id="L351">            StopWatch sw = new Log4JStopWatch();</span>
            // assemble lucky prize information
<span class="fc" id="L353">            this.assembleLuckyPrizeItem(prize, clientTicket, isPrizeEnquiry);</span>
<span class="fc" id="L354">            sw.stop(&quot;Assemble_Lucky_Prize&quot;, &quot;Assemble lucky draw prize of ticket(&quot; + clientTicket.getSerialNo() + &quot;)&quot;);</span>
        }

<span class="fc" id="L357">        this.assembleSecondPrize(prize, clientTicket, isPrizeEnquiry);</span>

        /**
         * update the prize statistics of prize information.
         */
<span class="fc bfc" id="L362" title="All 2 branches covered.">        for (PrizeItemDto prizeItem : prize.getPrizeItems()) {</span>
<span class="fc" id="L363">            prize.setPrizeAmount(prize.getPrizeAmount().add(prizeItem.getPrizeAmount()));</span>
<span class="fc" id="L364">            prize.setTaxAmount(prize.getTaxAmount().add(prizeItem.getTaxAmount()));</span>
<span class="fc" id="L365">            prize.setActualAmount(prize.getActualAmount().add(prizeItem.getActualAmount()));</span>
            // the lucky amount is object type prize, only for reference
<span class="fc" id="L367">            prize.setLuckyPrizeAmount(prize.getLuckyPrizeAmount().add(prizeItem.getObjectPrizeAmount()));</span>
<span class="fc" id="L368">        }</span>

<span class="fc" id="L370">        prize.setPayoutMode(this.lookupOperationParameter(soldTicket.getGameInstance().getGame()).getPayoutMode());</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">        if (BaseOperationParameter.PAYOUTMODE_REFUND == prize.getPayoutMode()) {</span>
<span class="fc" id="L372">            prize.setActualAmount(prize.getActualAmount().add(prize.getReturnAmount()));</span>
        }

<span class="fc" id="L375">        return prize;</span>
    }

    /**
     * If the tax calculation is based on per ticket(per draw), the tax and actual amount must be recalculated once the
     * prize statistics of a game instance has been determined. Otherwise both tax and actual amount will be 0.
     */
    protected void calculateTaxBasedOnPerTicket(PrizeDto prize, BaseTicket t, PrizeItemDto prizeItem) {
<span class="fc bfc" id="L383" title="All 2 branches covered.">        if (Game.TAXMETHOD_PAYOUT == t.getGameInstance().getGame().getTaxMethod()) {</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">            if (Game.TAXMETHOD_BASE_TICKET == t.getGameInstance().getGame().getTaxMethodBase()) {</span>
<span class="fc" id="L385">                BigDecimal totalPrizeAmountOfLevel = prizeItem.getPrizeAmount();</span>
                // calculate tax based on prize level amount.
<span class="fc" id="L387">                BigDecimal totalTaxAmountOfLevel = this.getTaxService().tax(totalPrizeAmountOfLevel,</span>
                        t.getGameInstance().getGame().getId());
<span class="fc" id="L389">                BigDecimal totalActualAmountOfLevel = totalPrizeAmountOfLevel.subtract(totalTaxAmountOfLevel);</span>
                // set total prize/actual amount
<span class="fc" id="L391">                prizeItem.setTaxAmount(prize.getTaxAmount().add(totalTaxAmountOfLevel));</span>
<span class="fc" id="L392">                prizeItem.setActualAmount(prize.getActualAmount().add(totalActualAmountOfLevel));</span>
            }
        }
<span class="fc" id="L395">    }</span>

    /**
     * Construct and initialize a &lt;code&gt;PrizeDto&lt;/code&gt; instance. Subclass can override this method to customize
     * initialization process, for example return a instance of &lt;code&gt;PrizeDto&lt;/code&gt;'s subclass.
     * 
     * @param clientTicket
     *            The ticket instance constructed based on client's request.
     * @param hostTickets
     *            The tickets records looked up at the backend.
     * @return a &lt;code&gt;PrizeDto&lt;/code&gt; instance.
     */
    protected PrizeDto newPrize(BaseTicket clientTicket, List&lt;? extends BaseTicket&gt; hostTickets) {
<span class="fc" id="L408">        PrizeDto prize = new PrizeDto();</span>
        // calculate total amount of multi-draw ticket.
<span class="fc" id="L410">        clientTicket.setTotalAmount(hostTickets.get(0).getTotalAmount().multiply(new BigDecimal(hostTickets.size())));</span>
<span class="fc" id="L411">        clientTicket.setGameInstance(hostTickets.get(0).getGameInstance());</span>
<span class="fc" id="L412">        prize.setWinningTicket(clientTicket);</span>
<span class="fc" id="L413">        return prize;</span>
    }

    /**
     * Assemble a PrizeItemDto which represents the winning statistics of a specific game instance based on winning
     * items.
     * &lt;p/&gt;
     * NOTE that for normal prize, only cash will be handled, no logic to handle object prize.
     */
    protected void assembleNormalPrizeItem(PrizeDto prize, PrizeItemDto prizeItem, BaseTicket ticket,
            List&lt;? extends BaseWinningItem&gt; winningItems) throws ApplicationException {
        // generate prize level items
<span class="fc bfc" id="L425" title="All 2 branches covered.">        for (BaseWinningItem winningItem : winningItems) {</span>
            // check if the winning item is valid
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">            if (!winningItem.isValid()) {</span>
<span class="nc" id="L428">                throw new ApplicationException(SystemException.CODE_CANCELED_WINNING_TICKET,</span>
                        &quot;can not payout a invalid winning item(id=&quot; + winningItem.getId() + &quot;).&quot;);
            }
<span class="fc" id="L431">            PrizeAmount prizeLevelAmount = this.lookupAnnouncedPrizeAmount(winningItem, ticket);</span>

            // lookup the prize level definition
<span class="fc" id="L434">            PrizeLevelItemDto levelDef = this.assemblePrizeLevelInfo(ticket.getGameInstance(),</span>
                    winningItem.getPrizeLevel(), prizeLevelAmount.getPrizeAmount(), prizeLevelAmount.getTaxAmount(),
                    prizeLevelAmount.getActualAmount(), winningItem.getNumberOfPrize());
<span class="fc" id="L437">            PrizeLevelItemDto existLevelItem = prizeItem.lookupPrizeLevelItem(winningItem.getPrizeLevel(), false);</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">            if (existLevelItem == null) {</span>
<span class="fc" id="L439">                existLevelItem = levelDef;</span>
<span class="fc" id="L440">                prizeItem.getPrizeLevelItems().add(existLevelItem);</span>
            } else {
<span class="fc" id="L442">                existLevelItem.setNumberOfPrizeLevel(existLevelItem.getNumberOfPrizeLevel()</span>
                        + levelDef.getNumberOfPrizeLevel());
            }

<span class="fc" id="L446">            this.updatePrizeStatPerDraw(prize, prizeItem, levelDef);</span>
<span class="fc" id="L447">        }</span>
<span class="fc" id="L448">    }</span>

    /**
     * Assemble second prize information. After the bingo can put the sales ticket again.Secondary items and cash two
     * modes
     * &lt;p/&gt;
     * Currently only supports the bingo game
     */
    protected void assembleSecondPrize(PrizeDto prize, BaseTicket t, boolean isPrizeEnquiry)
            throws ApplicationException {
<span class="fc" id="L458">    }</span>

    /**
     * Assemble lucky prize information. No matter the ticket is what game type, they all can join a lucky draw.
     * &lt;p/&gt;
     * For lucky draw, the object prize must be considered.
     */
    protected void assembleLuckyPrizeItem(PrizeDto prize, BaseTicket t, boolean isPrizeEnquiry)
            throws ApplicationException {
        // lookup winning items
<span class="fc" id="L468">        List&lt;LuckyDrawWinningItem&gt; luckyWinningItems = this.getBaseWinningItemDao().findBySerialNo(</span>
                LuckyDrawWinningItem.class, t.getSerialNo());
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L471">            logger.debug(&quot;Handle winnings of lucky draw of ticket(serialNo:&quot; + t.getSerialNo() + &quot;), total &quot;</span>
                    + luckyWinningItems.size() + &quot; winning items found.&quot;);
        }
        // handle the lucky winning item one by one...different from normal
        // prize which is handled draw by draw.
<span class="fc" id="L476">        List&lt;PrizeItemDto&gt; luckyPrizeItemList = new ArrayList&lt;PrizeItemDto&gt;();</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">        for (LuckyDrawWinningItem luckyWinningItem : luckyWinningItems) {</span>
            // check if the winning item is valid
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">            if (!luckyWinningItem.isValid()) {</span>
<span class="nc" id="L480">                throw new ApplicationException(SystemException.CODE_CANCELED_WINNING_TICKET,</span>
                        &quot;can not payout a invalid lucky winning item(id=&quot; + luckyWinningItem.getId() + &quot;).&quot;);
            }
            /**
             * lookup lucky-draw game instance ... refactor to reduce the enquiry of game instance, as multiple winning
             * items may associate with same game instance
             * &lt;p/&gt;
             * FIX - no worry, check the API doc of JPA2.0.
             * &lt;p/&gt;
             * Find by primary key. Search for an entity of the specified class and primary key. If the entity instance
             * is contained in the persistence context, it is returned from there.
             */
<span class="fc" id="L492">            LuckyGameInstance luckyGameInstance = this.baseJpaDao.findById(LuckyGameInstance.class,</span>
                    luckyWinningItem.getGameInstanceId());
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">            if (luckyGameInstance == null) {</span>
<span class="nc" id="L495">                throw new DataIntegrityViolationException(&quot;No lucky draw found by id(&quot;</span>
                        + luckyWinningItem.getGameInstanceId() + &quot;).&quot;);
            }

<span class="fc" id="L499">            PrizeItemDto prizeItem = prize.lookupPrizeItem(luckyGameInstance.getKey());</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">            if (prizeItem == null) {</span>
<span class="fc" id="L501">                prizeItem = new PrizeItemDto();</span>
<span class="fc" id="L502">                prizeItem.setGameInstance(luckyGameInstance);</span>
<span class="fc" id="L503">                prizeItem.getGameInstance().setGameId(luckyGameInstance.getGame().getId());</span>
<span class="fc" id="L504">                prizeItem.setType(PrizeGroupItem.GROUP_TYPE_GLOBAL_LUCKYDRAW);</span>
<span class="fc" id="L505">                prize.addPrizeItem(prizeItem);</span>
<span class="fc" id="L506">                luckyPrizeItemList.add(prizeItem);</span>
            }
<span class="fc" id="L508">            PrizeLevelItemDto prizeLevelItemDto = assemblePrizeItemFromBasePrizeLeveDef(</span>
                    luckyGameInstance.getPrizeLogicId(), luckyWinningItem, prizeItem);

<span class="fc" id="L511">            this.updatePrizeStatPerDraw(prize, prizeItem, prizeLevelItemDto);</span>

<span class="fc bfc" id="L513" title="All 2 branches covered.">            if (!isPrizeEnquiry) {</span>
<span class="fc" id="L514">                luckyWinningItem.setStatus(BaseTicket.STATUS_PAID);</span>
            }
<span class="fc" id="L516">        }</span>
<span class="fc" id="L517">        this.getBaseJpaDao().update(luckyWinningItems);</span>

<span class="fc bfc" id="L519" title="All 2 branches covered.">        for (PrizeItemDto luckyPrizeItem : luckyPrizeItemList) {</span>
<span class="fc" id="L520">            this.calculateTaxBasedOnPerTicket(prize, t, luckyPrizeItem);</span>
<span class="fc" id="L521">        }</span>
<span class="fc" id="L522">    }</span>

    /**
     * Assemble a &lt;code&gt;PrizeItemDto&lt;/code&gt; which represents a single winning item based on the base prize level
     * definition.
     * 
     * @return the prize level definition of the given &lt;code&gt;winningItem&lt;/code&gt;.
     */
    protected PrizeLevelItemDto assemblePrizeItemFromBasePrizeLeveDef(String prizeLogicId, BaseWinningItem winningItem,
            PrizeItemDto prizeItem) throws ApplicationException {
        // lookup prize level definition...for lucky draw, prize level
        // information must be retrieved from bd_prize_level.
<span class="fc" id="L534">        PrizeLevel prizeLevel = this.getPrizeLevelDao().findByPrizeLogicAndLevel(prizeLogicId,</span>
                winningItem.getPrizeLevel());
        // PrizeLevelItemDto only represents cash prize information
<span class="fc" id="L537">        PrizeLevelItemDto prizeLevelItemDto = null;</span>
        // sort prize-level-Item to guarantee cash prize will be handled first,
        // otherwise the object prize-level-item may be erased during the
        // handling of cash prize-level-item.
<span class="fc" id="L541">        Collections.sort(prizeLevel.getLevelItems(), new Comparator&lt;PrizeLevelItem&gt;() {</span>

            @Override
            public int compare(PrizeLevelItem o1, PrizeLevelItem o2) {
<span class="fc" id="L545">                return o1.getPrizeType() - o2.getPrizeType();</span>
            }
        });

<span class="fc bfc" id="L549" title="All 2 branches covered.">        for (PrizeLevelItem prizeLevelItem : prizeLevel.getLevelItems()) {</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">            if (PrizeLevel.PRIZE_TYPE_CASH == prizeLevelItem.getPrizeType()) {</span>
                // for cash, the prizeLevelItem.getNumberOfObject() should
                // always be 1.
<span class="fc" id="L553">                prizeLevelItemDto = this.assemblePrizeLevelInfo(prizeItem.getGameInstance(),</span>
                        winningItem.getPrizeLevel(), prizeLevelItem.getPrizeAmount(), prizeLevelItem.getTaxAmount(),
                        prizeLevelItem.getActualAmount(), winningItem.getNumberOfPrize());
            } else {
<span class="fc bfc" id="L557" title="All 2 branches covered.">                if (prizeLevelItemDto == null) {</span>
<span class="fc" id="L558">                    prizeLevelItemDto = new PrizeLevelItemDto();</span>
                    // the sum of object prize will be wrote to
                    // PrizeDto.luckyPrizeAmount...all object prize information
                    // will be stayed in PrizeLevelObjectItem.
<span class="fc" id="L562">                    prizeLevelItemDto.setPrizeLevel(prizeLevel.getPrizeLevel() + &quot;&quot;);</span>
<span class="fc" id="L563">                    prizeLevelItemDto.setNumberOfPrizeLevel(winningItem.getNumberOfPrize());</span>
                }
<span class="fc" id="L565">                PrizeLevelObjectItemDto objectItemDto = new PrizeLevelObjectItemDto();</span>
<span class="fc" id="L566">                objectItemDto.setObjectId(prizeLevelItem.getObjectId());</span>
<span class="fc" id="L567">                objectItemDto.setNumberOfObject(prizeLevelItem.getNumberOfObject());</span>
                // retrieve information from bd_prize_object
<span class="fc" id="L569">                BasePrizeObject prizeObject = this.getBaseJpaDao().findById(BasePrizeObject.class,</span>
                        prizeLevelItem.getObjectId());
                // objectItemDto.setObjectName(prizeLevelItem.getObjectName());
                // objectItemDto.setPrice(prizeLevelItem.getPrizeAmount());
                // objectItemDto.setTaxAmount(prizeLevelItem.getTaxAmount());
<span class="fc" id="L574">                objectItemDto.setObjectName(prizeObject.getName());</span>
<span class="fc" id="L575">                objectItemDto.setPrice(prizeObject.getPrice());</span>
<span class="fc" id="L576">                objectItemDto.setTaxAmount(prizeObject.getTax());</span>
<span class="fc" id="L577">                prizeLevelItemDto.getPrizeLevelObjectItems().add(objectItemDto);</span>
            }
<span class="fc" id="L579">        }</span>

        // multiple entries may all win same prize level
<span class="fc" id="L582">        PrizeLevelItemDto existLevelItem = prizeItem.lookupPrizeLevelItem(winningItem.getPrizeLevel(), false);</span>
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">        if (existLevelItem == null) {</span>
<span class="fc" id="L584">            existLevelItem = prizeLevelItemDto;</span>
<span class="fc" id="L585">            prizeItem.getPrizeLevelItems().add(existLevelItem);</span>
        } else {
<span class="nc" id="L587">            existLevelItem.setNumberOfPrizeLevel(existLevelItem.getNumberOfPrizeLevel()</span>
                    + prizeLevelItemDto.getNumberOfPrizeLevel());
        }
<span class="fc" id="L590">        return prizeLevelItemDto;</span>
    }

    protected PrizeLevelItemDto assemblePrizeLevelInfo(BaseGameInstance gameInstance, int prizeLevel,
            BigDecimal prizeAmount, BigDecimal taxAmount, BigDecimal actualAmount, int numberOfPrize)
            throws ApplicationException {
<span class="fc" id="L596">        PrizeLevelItemDto levelItem = new PrizeLevelItemDto();</span>
<span class="fc" id="L597">        levelItem.setPrizeLevel(prizeLevel + &quot;&quot;);</span>
<span class="fc" id="L598">        levelItem.setPrizeAmount(prizeAmount);</span>
        // calculate tax
        /**
         * If ticket wins in a lucky draw, tax calculation method should be based on lucky game instance.
         */
<span class="fc bfc" id="L603" title="All 2 branches covered.">        if (Game.TAXMETHOD_PAYOUT == gameInstance.getGame().getTaxMethod()) {</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">            if (Game.TAXMETHOD_BASE_BET == gameInstance.getGame().getTaxMethodBase()) {</span>
                // calculate tax based on prize level amount.
<span class="fc" id="L606">                taxAmount = this.getTaxService().tax(prizeAmount, gameInstance.getGame().getId());</span>
<span class="fc" id="L607">                actualAmount = prizeAmount.subtract(taxAmount);</span>
            } else {
<span class="fc" id="L609">                taxAmount = new BigDecimal(&quot;0&quot;);</span>
<span class="fc" id="L610">                actualAmount = new BigDecimal(&quot;0&quot;);</span>
            }
        }
<span class="fc" id="L613">        levelItem.setTaxAmount(taxAmount);</span>
<span class="fc" id="L614">        levelItem.setActualAmount(actualAmount);</span>

<span class="fc" id="L616">        levelItem.setNumberOfPrizeLevel(numberOfPrize);</span>
<span class="fc" id="L617">        return levelItem;</span>
    }

    /**
     * Update the prize statistics information of each game instance based on single prize level item.
     */
    protected void updatePrizeStatPerDraw(PrizeDto prize, PrizeItemDto prizeItem, PrizeLevelItemDto levelDef) {
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">        if (levelDef == null) {</span>
<span class="nc" id="L625">            return;</span>
        }
        // update prizeItem of per game instance
<span class="fc" id="L628">        prizeItem.setPrizeAmount(prizeItem.getPrizeAmount().add(</span>
                levelDef.getPrizeAmount().multiply(new BigDecimal(levelDef.getNumberOfPrizeLevel()))));
<span class="fc" id="L630">        prizeItem.setTaxAmount(prizeItem.getTaxAmount().add(</span>
                levelDef.getTaxAmount().multiply(new BigDecimal(levelDef.getNumberOfPrizeLevel()))));
<span class="fc" id="L632">        prizeItem.setActualAmount(prizeItem.getActualAmount().add(</span>
                levelDef.getActualAmount().multiply(new BigDecimal(levelDef.getNumberOfPrizeLevel()))));
<span class="fc bfc" id="L634" title="All 2 branches covered.">        for (PrizeLevelObjectItemDto objectItem : levelDef.getPrizeLevelObjectItems()) {</span>
<span class="fc" id="L635">            prizeItem.setObjectPrizeAmount(prizeItem.getObjectPrizeAmount().add(</span>
                    SimpleToolkit.mathMultiple(objectItem.getPrice(), new BigDecimal(
                            (objectItem.getNumberOfObject() * levelDef.getNumberOfPrizeLevel()) + &quot;&quot;))));
<span class="fc" id="L638">        }</span>
<span class="fc" id="L639">    }</span>

    /**
     * Lookup the announced prize amount of given prize level
     */
    protected abstract PrizeAmount lookupAnnouncedPrizeAmount(BaseWinningItem winningItem, BaseTicket ticket)
            throws ApplicationException;

    protected List&lt;? extends BaseWinningItem&gt; lookupWinningItem(String gameInstanceId, String ticketSerialNo,
            long version) throws ApplicationException {
<span class="fc" id="L649">        return this.getBaseWinningItemDao().findByGameInstanceAndSerialNoAndVersion(</span>
                this.supportedGameType().getWinningItemType(), gameInstanceId, ticketSerialNo, version);
    }

    protected List&lt;? extends BaseEntry&gt; lookupTicketEntriess(String serialNo) throws ApplicationException {
<span class="fc" id="L654">        return this.getBaseEntryDao().findByTicketSerialNo(this.supportedGameType().getTicketEntryType(), serialNo,</span>
                false);
    }

    protected List&lt;? extends BaseTicket&gt; lookupTickets(String serialNo) throws ApplicationException {
<span class="fc" id="L659">        return this.getBaseTicketDao().findBySerialNo(this.supportedGameType().getTicketType(), serialNo, false);</span>
    }

    /**
     * Determine whether the ticket is a winning(normal or lucky draw) ticket. A ticket may win either normal draw or
     * lucky draw. For multiple-draw tickets, if ticket wins any draw, it must be regarded as winning ticket.
     * 
     * @param clientTicket
     *            The ticket represents client request.
     * @param hostTickets
     *            THe tickets of server side representation.
     */
    protected void determineWinningStatus(BaseTicket clientTicket, List&lt;? extends BaseTicket&gt; hostTickets)
            throws ApplicationException {
<span class="fc bfc" id="L673" title="All 2 branches covered.">        for (BaseTicket hostTicket : hostTickets) {</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">            if (hostTicket.isWinning()) {</span>
<span class="fc" id="L675">                clientTicket.setWinning(true);</span>
            }
<span class="fc bfc" id="L677" title="All 2 branches covered.">            if (hostTicket.isLuckyWinning()) {</span>
<span class="fc" id="L678">                clientTicket.setLuckyWinning(true);</span>
            }
<span class="fc" id="L680">        }</span>

<span class="pc bpc" id="L682" title="3 of 4 branches missed.">        if (!clientTicket.isWinning() &amp;&amp; !clientTicket.isLuckyWinning()) {</span>
<span class="nc" id="L683">            throw new ApplicationException(SystemException.CODE_NOTWINNINGTICKET, &quot;Ticket(serialNo=&quot;</span>
                    + clientTicket.getSerialNo() + &quot;) isn't a winning ticket.&quot;);
        }
<span class="fc" id="L686">    }</span>

    protected BaseOperationParameter lookupOperationParameter(Game game) throws ApplicationException {
<span class="fc" id="L689">        return this.getBaseJpaDao().findById(this.supportedGameType().getOperationParametersType(),</span>
                game.getOperatorParameterId());
    }

    // -----------------------------------------------------------------------
    // SPRING DEPENDENCIES INJECTION
    // -----------------------------------------------------------------------

    public GameInstanceService getGameInstanceService() {
<span class="fc" id="L698">        return gameInstanceService;</span>
    }

    public void setGameInstanceService(GameInstanceService gameInstanceService) {
<span class="fc" id="L702">        this.gameInstanceService = gameInstanceService;</span>
<span class="fc" id="L703">    }</span>

    public BaseTicketDao getBaseTicketDao() {
<span class="fc" id="L706">        return baseTicketDao;</span>
    }

    public void setBaseTicketDao(BaseTicketDao baseTicketDao) {
<span class="fc" id="L710">        this.baseTicketDao = baseTicketDao;</span>
<span class="fc" id="L711">    }</span>

    public BaseEntryDao getBaseEntryDao() {
<span class="fc" id="L714">        return baseEntryDao;</span>
    }

    public void setBaseEntryDao(BaseEntryDao baseEntryDao) {
<span class="fc" id="L718">        this.baseEntryDao = baseEntryDao;</span>
<span class="fc" id="L719">    }</span>

    public MerchantService getMerchantService() {
<span class="fc" id="L722">        return merchantService;</span>
    }

    public void setMerchantService(MerchantService merchantService) {
<span class="fc" id="L726">        this.merchantService = merchantService;</span>
<span class="fc" id="L727">    }</span>

    public BaseJpaDao getBaseJpaDao() {
<span class="fc" id="L730">        return baseJpaDao;</span>
    }

    public void setBaseJpaDao(BaseJpaDao baseJpaDao) {
<span class="fc" id="L734">        this.baseJpaDao = baseJpaDao;</span>
<span class="fc" id="L735">    }</span>

    public BaseWinningItemDao getBaseWinningItemDao() {
<span class="fc" id="L738">        return baseWinningItemDao;</span>
    }

    public void setBaseWinningItemDao(BaseWinningItemDao baseWinningItemDao) {
<span class="fc" id="L742">        this.baseWinningItemDao = baseWinningItemDao;</span>
<span class="fc" id="L743">    }</span>

    public TaxService getTaxService() {
<span class="fc" id="L746">        return taxService;</span>
    }

    public void setTaxService(TaxService taxService) {
<span class="fc" id="L750">        this.taxService = taxService;</span>
<span class="fc" id="L751">    }</span>

    public PayoutStrategyFactory getPayoutStrategyFactory() {
<span class="fc" id="L754">        return payoutStrategyFactory;</span>
    }

    public void setPayoutStrategyFactory(PayoutStrategyFactory payoutStrategyFactory) {
<span class="fc" id="L758">        this.payoutStrategyFactory = payoutStrategyFactory;</span>
<span class="fc" id="L759">    }</span>

    public BaseWinningStatisticsDao getBaseWinningStatisticsDao() {
<span class="fc" id="L762">        return baseWinningStatisticsDao;</span>
    }

    public void setBaseWinningStatisticsDao(BaseWinningStatisticsDao baseWinningStatisticsDao) {
<span class="fc" id="L766">        this.baseWinningStatisticsDao = baseWinningStatisticsDao;</span>
<span class="fc" id="L767">    }</span>

    public PrizeLevelDao getPrizeLevelDao() {
<span class="fc" id="L770">        return prizeLevelDao;</span>
    }

    public void setPrizeLevelDao(PrizeLevelDao prizeLevelDao) {
<span class="fc" id="L774">        this.prizeLevelDao = prizeLevelDao;</span>
<span class="fc" id="L775">    }</span>

    public CreditService getCreditService() {
<span class="fc" id="L778">        return creditService;</span>
    }

    public void setCreditService(CreditService creditService) {
<span class="fc" id="L782">        this.creditService = creditService;</span>
<span class="fc" id="L783">    }</span>

    public BalanceTransactionsDao getBalanceTransactionsDao() {
<span class="nc" id="L786">        return balanceTransactionsDao;</span>
    }

    public void setBalanceTransactionsDao(BalanceTransactionsDao balanceTransactionsDao) {
<span class="nc" id="L790">        this.balanceTransactionsDao = balanceTransactionsDao;</span>
<span class="nc" id="L791">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.2.201302030002</span></div></body></html>