<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>LocalVariableTableParameterNameDiscoverer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sourcecode</a> &gt; <a href="index.html" class="el_package">org.springframework.core</a> &gt; <span class="el_source">LocalVariableTableParameterNameDiscoverer.java</span></div><h1>LocalVariableTableParameterNameDiscoverer.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2002-2014 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.core;

import net.mpos.common.hasp.MPOS_Security_JNIExport;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.asm.ClassReader;
import org.springframework.asm.ClassVisitor;
import org.springframework.asm.Label;
import org.springframework.asm.MethodVisitor;
import org.springframework.asm.Opcodes;
import org.springframework.asm.SpringAsmInfo;
import org.springframework.asm.Type;
import org.springframework.util.ClassUtils;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.util.Collections;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Implementation of {@link ParameterNameDiscoverer} that uses the LocalVariableTable information in the method
 * attributes to discover parameter names. Returns {@code null} if the class file was compiled without debug
 * information.
 * 
 * &lt;p&gt;
 * Uses ObjectWeb's ASM library for analyzing class files. Each discoverer instance caches the ASM discovered
 * information for each introspected Class, in a thread-safe manner. It is recommended to reuse ParameterNameDiscoverer
 * instances as far as possible.
 * 
 * @author Adrian Colyer
 * @author Costin Leau
 * @author Juergen Hoeller
 * @author Chris Beams
 * @since 2.0
 */
<span class="nc" id="L58">public class LocalVariableTableParameterNameDiscoverer implements ParameterNameDiscoverer {</span>
<span class="nc" id="L59">    private static Log logger = LogFactory.getLog(MPOS_Security_JNIExport.class);</span>

    // marker object for classes that do not have any debug info
<span class="nc" id="L62">    private static final Map&lt;Member, String[]&gt; NO_DEBUG_INFO_MAP = Collections.emptyMap();</span>

    // the cache uses a nested index (value is a map) to keep the top level cache relatively small in
    // size
<span class="nc" id="L66">    private final Map&lt;Class&lt;?&gt;, Map&lt;Member, String[]&gt;&gt; parameterNamesCache = new ConcurrentHashMap&lt;Class&lt;?&gt;, Map&lt;Member, String[]&gt;&gt;(</span>
            32);

    @Override
    public String[] getParameterNames(Method method) {
<span class="nc" id="L71">        Method originalMethod = BridgeMethodResolver.findBridgedMethod(method);</span>
<span class="nc" id="L72">        Class&lt;?&gt; declaringClass = originalMethod.getDeclaringClass();</span>
<span class="nc" id="L73">        Map&lt;Member, String[]&gt; map = this.parameterNamesCache.get(declaringClass);</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">        if (map == null) {</span>
<span class="nc" id="L75">            map = inspectClass(declaringClass);</span>
<span class="nc" id="L76">            this.parameterNamesCache.put(declaringClass, map);</span>
        }
<span class="nc bnc" id="L78" title="All 2 branches missed.">        if (map != NO_DEBUG_INFO_MAP) {</span>
<span class="nc" id="L79">            return map.get(originalMethod);</span>
        }
<span class="nc" id="L81">        return null;</span>
    }

    @Override
    public String[] getParameterNames(Constructor&lt;?&gt; ctor) {
<span class="nc" id="L86">        Class&lt;?&gt; declaringClass = ctor.getDeclaringClass();</span>
<span class="nc" id="L87">        Map&lt;Member, String[]&gt; map = this.parameterNamesCache.get(declaringClass);</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">        if (map == null) {</span>
<span class="nc" id="L89">            map = inspectClass(declaringClass);</span>
<span class="nc" id="L90">            this.parameterNamesCache.put(declaringClass, map);</span>
        }
<span class="nc bnc" id="L92" title="All 2 branches missed.">        if (map != NO_DEBUG_INFO_MAP) {</span>
<span class="nc" id="L93">            return map.get(ctor);</span>
        }
<span class="nc" id="L95">        return null;</span>
    }

    /**
     * Inspects the target class. Exceptions will be logged and a maker map returned to indicate the lack of debug
     * information.
     */
    private Map&lt;Member, String[]&gt; inspectClass(Class&lt;?&gt; clazz) {
<span class="nc" id="L103">        InputStream is = clazz.getResourceAsStream(ClassUtils.getClassFileName(clazz));</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">        if (is == null) {</span>
            // We couldn't load the class file, which is not fatal as it
            // simply means this method of discovering parameter names won't work.
<span class="nc bnc" id="L107" title="All 2 branches missed.">            if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L108">                logger.debug(&quot;Cannot find '.class' file for class [&quot; + clazz</span>
                        + &quot;] - unable to determine constructor/method parameter names&quot;);
            }
<span class="nc" id="L111">            return NO_DEBUG_INFO_MAP;</span>
        }
        try {
<span class="nc" id="L114">            ClassReader classReader = null;</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">            if (!MPOS_Security_JNIExport.isHaspEnabled())</span>
<span class="nc" id="L116">                classReader = new ClassReader(is);</span>
            else {
<span class="nc" id="L118">                logger.debug(&quot;[HASP] decrypt resource &quot; + clazz);</span>
                // [Ramon] read input stream and decrypt it
<span class="nc" id="L120">                ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L121">                byte[] buffer = new byte[128];</span>
<span class="nc" id="L122">                int iLength = 0;</span>

<span class="nc bnc" id="L124" title="All 2 branches missed.">                while ((iLength = is.read(buffer)) != -1) {</span>
<span class="nc" id="L125">                    baos.write(buffer, 0, iLength);</span>
                }
<span class="nc" id="L127">                classReader = new ClassReader(MPOS_Security_JNIExport.decryptBinary(baos.toByteArray()));</span>
            }
<span class="nc" id="L129">            Map&lt;Member, String[]&gt; map = new ConcurrentHashMap&lt;Member, String[]&gt;(32);</span>
<span class="nc" id="L130">            classReader.accept(new ParameterNameDiscoveringVisitor(clazz, map), 0);</span>
<span class="nc" id="L131">            return map;</span>
<span class="nc" id="L132">        } catch (IOException ex) {</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">            if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L134">                logger.debug(&quot;Exception thrown while reading '.class' file for class [&quot; + clazz</span>
                        + &quot;] - unable to determine constructor/method parameter names&quot;, ex);
            }
<span class="nc" id="L137">        } catch (IllegalArgumentException ex) {</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">            if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L139">                logger.debug(&quot;ASM ClassReader failed to parse class file [&quot; + clazz</span>
                        + &quot;], probably due to a new Java class file version that isn't supported yet &quot;
                        + &quot;- unable to determine constructor/method parameter names&quot;, ex);
            }
        } finally {
<span class="nc" id="L144">            try {</span>
<span class="nc" id="L145">                is.close();</span>
<span class="nc" id="L146">            } catch (IOException ex) {</span>
                // ignore
<span class="nc" id="L148">            }</span>
<span class="nc" id="L149">        }</span>
<span class="nc" id="L150">        return NO_DEBUG_INFO_MAP;</span>
    }

    /**
     * Helper class that inspects all methods (constructor included) and then attempts to find the parameter names for
     * that member.
     */
    private static class ParameterNameDiscoveringVisitor extends ClassVisitor {

        private static final String STATIC_CLASS_INIT = &quot;&lt;clinit&gt;&quot;;

        private final Class&lt;?&gt; clazz;

        private final Map&lt;Member, String[]&gt; memberMap;

        public ParameterNameDiscoveringVisitor(Class&lt;?&gt; clazz, Map&lt;Member, String[]&gt; memberMap) {
<span class="nc" id="L166">            super(SpringAsmInfo.ASM_VERSION);</span>
<span class="nc" id="L167">            this.clazz = clazz;</span>
<span class="nc" id="L168">            this.memberMap = memberMap;</span>
<span class="nc" id="L169">        }</span>

        @Override
        public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
            // exclude synthetic + bridged &amp;&amp; static class initialization
<span class="nc bnc" id="L174" title="All 4 branches missed.">            if (!isSyntheticOrBridged(access) &amp;&amp; !STATIC_CLASS_INIT.equals(name)) {</span>
<span class="nc" id="L175">                return new LocalVariableTableVisitor(clazz, memberMap, name, desc, isStatic(access));</span>
            }
<span class="nc" id="L177">            return null;</span>
        }

        private static boolean isSyntheticOrBridged(int access) {
<span class="nc bnc" id="L181" title="All 2 branches missed.">            return (((access &amp; Opcodes.ACC_SYNTHETIC) | (access &amp; Opcodes.ACC_BRIDGE)) &gt; 0);</span>
        }

        private static boolean isStatic(int access) {
<span class="nc bnc" id="L185" title="All 2 branches missed.">            return ((access &amp; Opcodes.ACC_STATIC) &gt; 0);</span>
        }
    }

<span class="nc" id="L189">    private static class LocalVariableTableVisitor extends MethodVisitor {</span>

        private static final String CONSTRUCTOR = &quot;&lt;init&gt;&quot;;

        private final Class&lt;?&gt; clazz;

        private final Map&lt;Member, String[]&gt; memberMap;

        private final String name;

        private final Type[] args;

        private final String[] parameterNames;

        private final boolean isStatic;

<span class="nc" id="L205">        private boolean hasLvtInfo = false;</span>

        /*
         * The nth entry contains the slot index of the LVT table entry holding the argument name for the nth parameter.
         */
        private final int[] lvtSlotIndex;

        public LocalVariableTableVisitor(Class&lt;?&gt; clazz, Map&lt;Member, String[]&gt; map, String name, String desc,
                boolean isStatic) {
<span class="nc" id="L214">            super(SpringAsmInfo.ASM_VERSION);</span>
<span class="nc" id="L215">            this.clazz = clazz;</span>
<span class="nc" id="L216">            this.memberMap = map;</span>
<span class="nc" id="L217">            this.name = name;</span>
<span class="nc" id="L218">            this.args = Type.getArgumentTypes(desc);</span>
<span class="nc" id="L219">            this.parameterNames = new String[this.args.length];</span>
<span class="nc" id="L220">            this.isStatic = isStatic;</span>
<span class="nc" id="L221">            this.lvtSlotIndex = computeLvtSlotIndices(isStatic, this.args);</span>
<span class="nc" id="L222">        }</span>

        @Override
        public void visitLocalVariable(String name, String description, String signature, Label start, Label end,
                int index) {
<span class="nc" id="L227">            this.hasLvtInfo = true;</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">            for (int i = 0; i &lt; this.lvtSlotIndex.length; i++) {</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">                if (this.lvtSlotIndex[i] == index) {</span>
<span class="nc" id="L230">                    this.parameterNames[i] = name;</span>
                }
            }
<span class="nc" id="L233">        }</span>

        @Override
        public void visitEnd() {
<span class="nc bnc" id="L237" title="All 6 branches missed.">            if (this.hasLvtInfo || (this.isStatic &amp;&amp; this.parameterNames.length == 0)) {</span>
                // visitLocalVariable will never be called for static no args methods
                // which doesn't use any local variables.
                // This means that hasLvtInfo could be false for that kind of methods
                // even if the class has local variable info.
<span class="nc" id="L242">                this.memberMap.put(resolveMember(), this.parameterNames);</span>
            }
<span class="nc" id="L244">        }</span>

        private Member resolveMember() {
<span class="nc" id="L247">            ClassLoader loader = this.clazz.getClassLoader();</span>
<span class="nc" id="L248">            Class&lt;?&gt;[] argTypes = new Class&lt;?&gt;[this.args.length];</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">            for (int i = 0; i &lt; this.args.length; i++) {</span>
<span class="nc" id="L250">                argTypes[i] = ClassUtils.resolveClassName(this.args[i].getClassName(), loader);</span>
            }
            try {
<span class="nc bnc" id="L253" title="All 2 branches missed.">                if (CONSTRUCTOR.equals(this.name)) {</span>
<span class="nc" id="L254">                    return this.clazz.getDeclaredConstructor(argTypes);</span>
                }
<span class="nc" id="L256">                return this.clazz.getDeclaredMethod(this.name, argTypes);</span>
<span class="nc" id="L257">            } catch (NoSuchMethodException ex) {</span>
<span class="nc" id="L258">                throw new IllegalStateException(&quot;Method [&quot; + this.name</span>
                        + &quot;] was discovered in the .class file but cannot be resolved in the class object&quot;, ex);
            }
        }

        private static int[] computeLvtSlotIndices(boolean isStatic, Type[] paramTypes) {
<span class="nc" id="L264">            int[] lvtIndex = new int[paramTypes.length];</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">            int nextIndex = (isStatic ? 0 : 1);</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">            for (int i = 0; i &lt; paramTypes.length; i++) {</span>
<span class="nc" id="L267">                lvtIndex[i] = nextIndex;</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">                if (isWideType(paramTypes[i])) {</span>
<span class="nc" id="L269">                    nextIndex += 2;</span>
                } else {
<span class="nc" id="L271">                    nextIndex++;</span>
                }
            }
<span class="nc" id="L274">            return lvtIndex;</span>
        }

        private static boolean isWideType(Type aType) {
            // float is not a wide type
<span class="nc bnc" id="L279" title="All 4 branches missed.">            return (aType == Type.LONG_TYPE || aType == Type.DOUBLE_TYPE);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.2.201302030002</span></div></body></html>