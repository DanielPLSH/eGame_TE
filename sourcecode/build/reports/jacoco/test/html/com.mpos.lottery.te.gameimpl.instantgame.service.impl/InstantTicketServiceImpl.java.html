<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>InstantTicketServiceImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sourcecode</a> &gt; <a href="index.html" class="el_package">com.mpos.lottery.te.gameimpl.instantgame.service.impl</a> &gt; <span class="el_source">InstantTicketServiceImpl.java</span></div><h1>InstantTicketServiceImpl.java</h1><pre class="source lang-java linenums">package com.mpos.lottery.te.gameimpl.instantgame.service.impl;

import com.google.gson.Gson;

import com.mpos.lottery.te.common.Constants;
import com.mpos.lottery.te.config.MLotteryContext;
import com.mpos.lottery.te.config.SysConfiguration;
import com.mpos.lottery.te.config.dao.SysConfigurationDao;
import com.mpos.lottery.te.config.exception.ApplicationException;
import com.mpos.lottery.te.config.exception.SystemException;
import com.mpos.lottery.te.gameimpl.instantgame.dao.IGBatchReportDao;
import com.mpos.lottery.te.gameimpl.instantgame.dao.IGFailedTicketsReportDao;
import com.mpos.lottery.te.gameimpl.instantgame.dao.IGPayoutDetailTempDao;
import com.mpos.lottery.te.gameimpl.instantgame.dao.IGPayoutTempDao;
import com.mpos.lottery.te.gameimpl.instantgame.dao.InstantTicketDao;
import com.mpos.lottery.te.gameimpl.instantgame.dao.InstantVIRNPrizeDao;
import com.mpos.lottery.te.gameimpl.instantgame.domain.IGBatchReport;
import com.mpos.lottery.te.gameimpl.instantgame.domain.IGFailedTicketsReport;
import com.mpos.lottery.te.gameimpl.instantgame.domain.IGPayoutDetailTemp;
import com.mpos.lottery.te.gameimpl.instantgame.domain.IGPayoutTemp;
import com.mpos.lottery.te.gameimpl.instantgame.domain.InstantGameDraw;
import com.mpos.lottery.te.gameimpl.instantgame.domain.InstantTicket;
import com.mpos.lottery.te.gameimpl.instantgame.domain.InstantTicketSerialNo;
import com.mpos.lottery.te.gameimpl.instantgame.domain.dto.ActiveCriteria;
import com.mpos.lottery.te.gameimpl.instantgame.domain.dto.ActiveResult;
import com.mpos.lottery.te.gameimpl.instantgame.domain.dto.ConfirmBatchPayoutDto;
import com.mpos.lottery.te.gameimpl.instantgame.domain.dto.InstantBatchPayoutDto;
import com.mpos.lottery.te.gameimpl.instantgame.domain.dto.InstantBatchReportDto;
import com.mpos.lottery.te.gameimpl.instantgame.domain.dto.InstantOfflineTicketResult;
import com.mpos.lottery.te.gameimpl.instantgame.domain.dto.InstantOfflineTickets;
import com.mpos.lottery.te.gameimpl.instantgame.domain.dto.InstantTicketResult;
import com.mpos.lottery.te.gameimpl.instantgame.domain.dto.Packet;
import com.mpos.lottery.te.gameimpl.instantgame.domain.dto.PrizeLevelDto;
import com.mpos.lottery.te.gameimpl.instantgame.domain.dto.PrizeLevelItemDto;
import com.mpos.lottery.te.gameimpl.instantgame.domain.logic.ValidationStrategy;
import com.mpos.lottery.te.gameimpl.instantgame.domain.logic.active.CriteriaActiveStrategy;
import com.mpos.lottery.te.gameimpl.instantgame.service.InstantTicketService;
import com.mpos.lottery.te.gameimpl.lotto.prize.dao.PrizeObjectDao;
import com.mpos.lottery.te.gamespec.game.Game;
import com.mpos.lottery.te.gamespec.game.GameType;
import com.mpos.lottery.te.gamespec.prize.Payout;
import com.mpos.lottery.te.gamespec.prize.PayoutDetail;
import com.mpos.lottery.te.gamespec.prize.PrizeGroupItem;
import com.mpos.lottery.te.gamespec.prize.dao.PayoutDao;
import com.mpos.lottery.te.gamespec.prize.dao.PayoutDetailDao;
import com.mpos.lottery.te.gamespec.sale.BaseTicket;
import com.mpos.lottery.te.merchant.dao.BalanceTransactionsDao;
import com.mpos.lottery.te.merchant.domain.BalanceTransactions;
import com.mpos.lottery.te.merchant.domain.Merchant;
import com.mpos.lottery.te.merchant.service.CreditService;
import com.mpos.lottery.te.merchant.service.MerchantService;
import com.mpos.lottery.te.merchant.service.balance.BalanceService;
import com.mpos.lottery.te.merchant.service.commission.CommissionBalanceService;
import com.mpos.lottery.te.merchant.web.PayoutLevelAllowRequest;
import com.mpos.lottery.te.port.Context;
import com.mpos.lottery.te.sequence.service.UUIDService;
import com.mpos.lottery.te.trans.domain.TransactionMessage;
import com.mpos.lottery.te.trans.domain.TransactionType;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.Resource;

<span class="fc" id="L75">public class InstantTicketServiceImpl implements InstantTicketService {</span>
<span class="fc" id="L76">    private Log logger = LogFactory.getLog(InstantTicketServiceImpl.class);</span>

    private InstantTicketDao instantTicketDao;

    private InstantVIRNPrizeDao instantVIRNPrizeDao;

    private PayoutDao payoutDao;

    private SysConfigurationDao sysConfigurationDao;

    private ValidationStrategy validationStrategy;

    private CreditService creditService;

    private MerchantService merchantService;

    private CriteriaActiveStrategy criteriaActiveStrategy;

    private UUIDService uuidManager;

    private PrizeObjectDao prizeObjectDao;

    private PayoutDetailDao payoutDetailDao;

    private IGBatchReportDao iGBatchReportDao;

    private IGFailedTicketsReportDao iGFailedTicketsReportDao;

    private IGPayoutDetailTempDao iGPayoutDetailTempDao;

    private IGPayoutTempDao iGPayoutTempDao;
    @Resource(name = &quot;balanceTransactionsDao&quot;)
    private BalanceTransactionsDao balanceTransactionsDao;
    @Resource(name = &quot;payoutCommissionBalanceService&quot;)
    private CommissionBalanceService commissionBalanceService;
    @Resource(name = &quot;defaultBalanceService&quot;)
    private BalanceService balanceService;

    /**
     * @see InstantTicketService#active(ActiveCriteria)
     */
    public ActiveResult active(ActiveCriteria criteria) throws ApplicationException {
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L119">            logger.debug(&quot;Start to active ticket by criteria: &quot; + criteria.toString());</span>
        }

<span class="nc" id="L122">        ActiveResult result = this.getCriteriaActiveStrategy().active(criteria);</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">        if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L124">            logger.debug(&quot;The active result: &quot; + result.toString());</span>
        }
<span class="nc" id="L126">        return result;</span>
    }

    /**
     * @see InstantTicketService#active(InstantTicket)
     */
    public InstantTicket active(InstantTicket ticket) throws ApplicationException {
<span class="fc" id="L133">        InstantTicket hostTicket = this.getInstantTicketDao().getBySerialNo(ticket.getSerialNo());</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (hostTicket == null) {</span>
<span class="nc" id="L135">            throw new ApplicationException(SystemException.CODE_NO_TICKET,</span>
                    &quot;can NOT find instant ticket with serialNO='&quot; + ticket.getSerialNo() + &quot;.&quot;);
        }
<span class="fc" id="L138">        ticket.setTotalAmount(hostTicket.getGameDraw().getTicketFaceValue());</span>
        // transfer between InstantTicket and ActiveCriteria
<span class="fc" id="L140">        ActiveCriteria criteria = new ActiveCriteria();</span>
<span class="fc" id="L141">        criteria.setType(ActiveCriteria.TYPE_BYSINGLETICKET);</span>
<span class="fc" id="L142">        criteria.setValue(ticket.getSerialNo());</span>
<span class="fc" id="L143">        criteria.setTrans(ticket.getTransaction());</span>
<span class="fc" id="L144">        ActiveResult result = this.getCriteriaActiveStrategy().active(criteria);</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">        if (result.getCount() != 1) { // fail to active</span>
<span class="nc" id="L146">            throw new ApplicationException(result.getErrorCode(), &quot;Fail to active ticket(serialNo='&quot;</span>
                    + ticket.getSerialNo() + &quot;').&quot;);
        }

<span class="fc" id="L150">        return ticket;</span>
    }

    /**
     * @see InstantTicketService#offlineInfoUpload(InstantOfflineTickets)
     */
    public InstantOfflineTicketResult offlineInfoUpload(InstantOfflineTickets offlineTicket)
            throws ApplicationException {
<span class="nc" id="L158">        List&lt;InstantTicket&gt; tickets = offlineTicket.getTickets();</span>
<span class="nc" id="L159">        List&lt;InstantTicketResult&gt; results = new ArrayList&lt;InstantTicketResult&gt;();</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">        for (InstantTicket ticket : tickets) {</span>
<span class="nc" id="L161">            InstantTicketResult result = new InstantTicketResult();</span>
<span class="nc" id="L162">            result.setSerialNo(ticket.getSerialNo());</span>
<span class="nc" id="L163">            result.setCode(SystemException.CODE_OK);</span>
            // just update ticket
<span class="nc" id="L165">            InstantTicket hostTicket = this.getInstantTicketDao().getBySerialNo(ticket.getSerialNo());</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">            if (hostTicket == null) {</span>
<span class="nc" id="L167">                logger.warn(&quot;can NOT find instant ticket with serialNO='&quot; + ticket.getSerialNo() + &quot;.&quot;);</span>
<span class="nc" id="L168">                result.setCode(SystemException.CODE_NO_TICKET);</span>
<span class="nc" id="L169">                result.setTotalAmount(new BigDecimal(&quot;0&quot;));</span>
<span class="nc" id="L170">                results.add(result);</span>
<span class="nc" id="L171">                continue;</span>
            }
<span class="nc" id="L173">            result.setTotalAmount(hostTicket.getGameDraw().getTicketFaceValue());</span>
<span class="nc" id="L174">            hostTicket.setSoldToCustomer(true);</span>
<span class="nc" id="L175">            hostTicket.setSoldTime(ticket.getSoldTime());</span>
            // persist ticket
<span class="nc" id="L177">            this.getInstantTicketDao().update(hostTicket);</span>
<span class="nc" id="L178">            results.add(result);</span>
<span class="nc" id="L179">        }</span>
<span class="nc" id="L180">        InstantOfflineTicketResult result = new InstantOfflineTicketResult();</span>
<span class="nc" id="L181">        result.setResults(results);</span>
<span class="nc" id="L182">        return result;</span>
    }

    /**
     * Validate a ticket to ensure whether it wins a cash/object prize. When persists payout transaction, the process
     * must follow below rule:
     * &lt;ul&gt;
     * &lt;li&gt;The prize_amount/tax_amount of table 'PAYOUT' only count both cash and object prize.&lt;/li&gt;
     * &lt;li&gt;All payout details, including cash prize and object prize, must be persisted into table 'PAYOUT_DETAIL'.&lt;/li&gt;
     * &lt;/ul&gt;
     * For example, a ticket wins both cash and object prize:
     * &lt;table border=&quot;1&quot;&gt;
     * &lt;tr&gt;
     * &lt;td&gt;prize type&lt;/td&gt;
     * &lt;td&gt;price amount&lt;/td&gt;
     * &lt;td&gt;tax_amount&lt;/td&gt;
     * &lt;td&gt;prize name&lt;/td&gt;
     * &lt;td&gt;number of prize&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     * &lt;td&gt;cash&lt;/td&gt;
     * &lt;td&gt;500.0&lt;/td&gt;
     * &lt;td&gt;100.0&lt;/td&gt;
     * &lt;td&gt;_&lt;/td&gt;
     * &lt;td&gt;_&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     * &lt;td&gt;object&lt;/td&gt;
     * &lt;td&gt;2000.0&lt;/td&gt;
     * &lt;td&gt;400.0&lt;/td&gt;
     * &lt;td&gt;Seagull Digital Camera&lt;/td&gt;
     * &lt;td&gt;2&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;/table&gt;
     * &lt;p&gt;
     * After committed, 1 payout will be persisted in table 'PAYOUT'(both cash and object prize):
     * &lt;table border=&quot;1&quot;&gt;
     * &lt;tr&gt;
     * &lt;td&gt;id&lt;/td&gt;
     * &lt;td&gt;prize amount&lt;/td&gt;
     * &lt;td&gt;tax_amount&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     * &lt;td&gt;1&lt;/td&gt;
     * &lt;td&gt;500.0&lt;/td&gt;
     * &lt;td&gt;100.0&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;/table&gt;
     * &lt;p&gt;
     * And 2 records in table 'PAYOUT_DETAIL':
     * &lt;table border=&quot;1&quot;&gt;
     * &lt;tr&gt;
     * &lt;td&gt;prize type&lt;/td&gt;
     * &lt;td&gt;prize amount&lt;/td&gt;
     * &lt;td&gt;tax amount&lt;/td&gt;
     * &lt;td&gt;prize name&lt;/td&gt;
     * &lt;td&gt;number of prize&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     * &lt;td&gt;cash&lt;/td&gt;
     * &lt;td&gt;500.0&lt;/td&gt;
     * &lt;td&gt;100.0&lt;/td&gt;
     * &lt;td&gt;_&lt;/td&gt;
     * &lt;td&gt;1(always be 1)&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;tr&gt;
     * &lt;td&gt;object&lt;/td&gt;
     * &lt;td&gt;2000.0&lt;/td&gt;
     * &lt;td&gt;400.0&lt;/td&gt;
     * &lt;td&gt;Seagull Digital Camera&lt;/td&gt;
     * &lt;td&gt;2&lt;/td&gt;
     * &lt;/tr&gt;
     * &lt;/table&gt;
     * 
     * @see InstantTicketService#validate(Context, PrizeLevelDto)
     * @see #enquiryPrize(Context, InstantTicket, boolean)
     */
    public PrizeLevelDto validate(Context ctx, PrizeLevelDto payoutDto) throws ApplicationException {
        /**
         * Why we put validation logic in a new method 'doValidate()'? As this service method 'validate(...)' is
         * transaction awared, and there are another transactional method 'batchValidate(...)', just as the name
         * implies, 'batchValidate()' will call 'validate()' multiple times to handle ticket one by one. What is more is
         * failure of one ticket should not affect another ticket. That says even fail to validate one ticket, it should
         * keep validating the next ticket.
         * &lt;p&gt;
         * Let imagine a case if all validation logic is implemented in 'validate(...)' method. batch validation prepare
         * to validate 3 tickets, and the 1st is successful, however the 2nd encounter a failure and 'validate()' throw
         * out a ApplicationException which will mark current transaction as rollback-only......
         * &lt;p&gt;
         * Oh, actually the above case won't happen if Spring support transaction by dynamic proxy, as the proxy can
         * only wrap on interface, not method level(can achieve by ASM, byte code wave, proxy transaction for each
         * method). So when 'batchValidate()' call 'validate()', as they are in same instance, no transactional checking
         * will happen on 'validate()'.
         */
<span class="fc" id="L276">        return this.doValidate(ctx, payoutDto);</span>
    }

    /**
     * @see InstantTicketService#batchValidate(Context, InstantBatchPayoutDto)
     */
    public InstantBatchPayoutDto batchValidate(Context ctx, InstantBatchPayoutDto batchPayout)
            throws ApplicationException {
<span class="nc" id="L284">        InstantBatchPayoutDto dto = new InstantBatchPayoutDto();</span>
<span class="nc" id="L285">        boolean isSamePrizeType = true;</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">        for (PrizeLevelDto payout : batchPayout.getPayouts()) {</span>
<span class="nc" id="L287">            PrizeLevelDto prizeLevel = null;</span>
            try {
<span class="nc" id="L289">                prizeLevel = this.validate(ctx, payout);</span>

                // all successful validations must be same prize type...WHY???
                // disable it!
                // if (prizeType == null)
                // prizeType = result.getPrizeType() + &quot;&quot;;
                // else if (!prizeType.equals(result.getPrizeType())) {
                // isSamePrizeType = false;
                // break;
                // }
                // assemble result
<span class="nc" id="L300">                dto.setActualAmount(dto.getActualAmount().add(prizeLevel.getActualAmount()));</span>
<span class="nc" id="L301">                dto.setTaxAmount(dto.getTaxAmount().add(prizeLevel.getTaxAmount()));</span>
<span class="nc" id="L302">                dto.setTotalSuccess(dto.getTotalSuccess() + 1);</span>
            }
            // one failed validation shouldn't affect other tickets
<span class="nc" id="L305">            catch (ApplicationException e) { // can and ONLY can handle</span>
                                             // ApplicationException
                                             // write log
<span class="nc" id="L308">                logger.warn(e.getMessage(), e);</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">                if (prizeLevel == null) {</span>
<span class="nc" id="L310">                    prizeLevel = new PrizeLevelDto();</span>
                }
<span class="nc" id="L312">                prizeLevel.setErrorCode(e.getErrorCode());</span>
<span class="nc" id="L313">                prizeLevel.setTicket(payout.getTicket());</span>
<span class="nc" id="L314">                dto.setTotalFail(dto.getTotalFail() + 1);</span>
<span class="nc" id="L315">            }</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">            if (prizeLevel != null) {</span>
<span class="nc" id="L317">                dto.getPayouts().add(prizeLevel);</span>
            }

<span class="nc bnc" id="L320" title="All 2 branches missed.">            if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L321">                logger.debug(&quot;Finish handling validate ticket(serialNo=&quot; + payout.getTicket().getSerialNo() + &quot;):&quot;</span>
                        + payout.toString());
            }
<span class="nc" id="L324">        }</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">        if (!isSamePrizeType) {</span>
<span class="nc" id="L326">            throw new ApplicationException(SystemException.CODE_BATCH_VALIDATION_NOT_SAME_TYPE,</span>
                    &quot;the prize type of all successful validation must be same type.&quot;);
        }
<span class="nc" id="L329">        return dto;</span>
    }

    /**
     * @see InstantTicketService#receive(Packet)
     */
    public void receive(Packet packet) throws ApplicationException {
        // not yet implemented
<span class="nc" id="L337">    }</span>

    /**
     * @see InstantTicketService#sell(InstantTicket)
     */
    public InstantTicket sell(InstantTicket ticket) throws ApplicationException {
<span class="nc" id="L343">        InstantTicket hostTicket = this.getInstantTicketDao().getBySerialNo(ticket.getSerialNo());</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (hostTicket == null) {</span>
<span class="nc" id="L345">            throw new ApplicationException(SystemException.CODE_NO_TICKET,</span>
                    &quot;can NOT find instant ticket with serialNO='&quot; + ticket.getSerialNo() + &quot;.&quot;);
        }
        // set gameId
<span class="nc" id="L349">        ticket.getTransaction().setGameId(hostTicket.getGameDraw().getGame().getId());</span>
        // check if the ticket is damaged
<span class="nc bnc" id="L351" title="All 2 branches missed.">        if (InstantTicket.PHYSICAL_STATUS_DAMAGED == hostTicket.getPhysicalStatus()) {</span>
<span class="nc" id="L352">            throw new ApplicationException(SystemException.CODE_ONE_DAMAGETICKET, &quot;Ticket(serialNo=&quot;</span>
                    + hostTicket.getSerialNo() + &quot;) is damaged.&quot;);
        }
<span class="nc" id="L355">        this.verifyBlacklist(hostTicket);</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">        if (InstantTicket.STATUS_INACTIVE != hostTicket.getStatus()) {</span>
<span class="nc" id="L357">            throw new ApplicationException(SystemException.CODE_SELL_INACTIVETICKET,</span>
                    &quot;only inactive ticket can be sold realtime, current status:&quot; + hostTicket.getStatus());
        }
<span class="nc" id="L360">        hostTicket.setStatus(InstantTicket.STATUS_ACTIVE);</span>
<span class="nc" id="L361">        hostTicket.setSoldToCustomer(true);</span>
<span class="nc" id="L362">        hostTicket.setSoldTime(new Date());</span>

        // added by Lee,2010-07-23,
<span class="nc" id="L365">        hostTicket.setOperatorId(ticket.getTransaction().getOperatorId());</span>
<span class="nc" id="L366">        hostTicket.setDevId(String.valueOf(ticket.getTransaction().getDeviceId()));</span>
<span class="nc" id="L367">        hostTicket.setMerchantId(String.valueOf(ticket.getTransaction().getMerchantId()));</span>

<span class="nc" id="L369">        this.getInstantTicketDao().update(hostTicket);</span>
        // return dto
<span class="nc" id="L371">        ticket.setTotalAmount(hostTicket.getGameDraw().getTicketFaceValue());</span>
<span class="nc" id="L372">        return ticket;</span>
    }

    /**
     * This operation will calculate the detailed prize information of a given ticket. The prize calculation logic will
     * be illustrated by below diagram. &lt;img src=&quot;../doc-files/IG validation prize calculation logic.png&quot;/&gt;
     */
    @Override
    public PrizeLevelDto enquiryPrize(Context respCtx, InstantTicket ticket, boolean isWinnerCounted)
            throws ApplicationException {
<span class="fc" id="L382">        InstantTicket hostTicket = this.getInstantTicketDao().getBySerialNo(ticket.getSerialNo());</span>
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">        if (hostTicket == null) {</span>
<span class="nc" id="L384">            throw new ApplicationException(SystemException.CODE_NO_TICKET,</span>
                    &quot;can NOT find instant ticket with serialNO='&quot; + ticket.getSerialNo() + &quot;.&quot;);
        }
<span class="fc bfc" id="L387" title="All 2 branches covered.">        if (InstantTicket.STATUS_VALIDATED == hostTicket.getStatus()) {</span>
<span class="fc" id="L388">            throw new ApplicationException(SystemException.CODE_VALIDATE_REPEAT, &quot;ticket(&quot; + hostTicket.getSerialNo()</span>
                    + &quot;) is already validated.&quot;);
        }
<span class="fc" id="L391">        hostTicket.setTransaction(respCtx.getTransaction());</span>
<span class="fc" id="L392">        hostTicket.setRawSerialNo(false, ticket.getRawSerialNo());</span>
<span class="fc" id="L393">        PrizeLevelDto prize = this.getValidationStrategy().validate(hostTicket, ticket.getTicketXOR3(), true);</span>
        // avoid hibernate lazy intialization of collection
<span class="fc" id="L395">        prize.calculateAmount();</span>
<span class="fc" id="L396">        prize.setTicket(ticket);</span>
<span class="fc" id="L397">        return prize;</span>
    }

    @Override
    public InstantBatchPayoutDto offlineBatchValidate(Context ctx, InstantBatchPayoutDto req)
            throws ApplicationException {
<span class="nc" id="L403">        InstantBatchPayoutDto resultDto = new InstantBatchPayoutDto();</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">        for (PrizeLevelDto clientPrize : req.getPayouts()) {</span>
            // iterate on each valiation transaction

<span class="nc" id="L407">            InstantTicket clientTicket = clientPrize.getTicket();</span>
<span class="nc" id="L408">            InstantTicket hostTicket = this.getInstantTicketDao().getBySerialNo(clientTicket.getSerialNo());</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">            if (hostTicket == null) {</span>
                // TODO: need more handling??
<span class="nc" id="L411">                logger.warn(&quot;No instant ticket found at the backend by serialNO=&quot; + clientTicket.getSerialNo());</span>
<span class="nc" id="L412">                continue;</span>
            }
<span class="nc" id="L414">            hostTicket.setTransaction(ctx.getTransaction());</span>
<span class="nc" id="L415">            hostTicket.setRawSerialNo(false, clientTicket.getRawSerialNo());</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">            boolean hasValidated = InstantTicket.STATUS_VALIDATED == hostTicket.getStatus();</span>
<span class="nc" id="L417">            boolean matched = true;</span>
            // calcuate the prize amount
<span class="nc" id="L419">            PrizeLevelDto hostPrize = this.getValidationStrategy().validate(hostTicket, clientTicket.getTicketXOR3(),</span>
                    false);
<span class="nc" id="L421">            hostPrize.calculateAmount();</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">            if (hostPrize.getPrizeAmount().compareTo(clientPrize.getPrizeAmount()) != 0) {</span>
<span class="nc" id="L423">                logger.warn(&quot;The prize amount of ticket(serialNo=&quot; + clientTicket.getSerialNo() + &quot;) is &quot;</span>
                        + hostPrize.getPrizeAmount() + &quot;, but client request &quot; + clientPrize.getPrizeAmount());
<span class="nc" id="L425">                matched = false;</span>

            }
<span class="nc bnc" id="L428" title="All 2 branches missed.">            if (!hasValidated) {</span>
                // mark the ticket as validated
<span class="nc" id="L430">                hostTicket.setStatus(InstantTicket.STATUS_VALIDATED);</span>
<span class="nc" id="L431">                this.getInstantTicketDao().update(hostTicket);</span>

                // generate payout records...even prize amount is unmatched,
                // payout must record the client's prize amount, as the cash has
                // been paid.
<span class="nc" id="L436">                clientPrize.calculateAmount();</span>
<span class="nc" id="L437">                clientPrize.setLevelItems(hostPrize.getLevelItems());</span>
<span class="nc" id="L438">                this.generatePayout(hostTicket, clientPrize);</span>
            }

<span class="nc" id="L441">            clientPrize.setPrizeAmount(hostPrize.getPrizeAmount());</span>
<span class="nc" id="L442">            clientPrize.setActualAmount(hostPrize.getActualAmount());</span>
<span class="nc" id="L443">            clientPrize.setTaxAmount(hostPrize.getTaxAmount());</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">            if (hasValidated) {</span>
<span class="nc" id="L445">                resultDto.getPayouts().add(clientPrize);</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">                if (matched) {</span>
<span class="nc" id="L447">                    clientPrize.setStatusCode(PrizeLevelDto.STATUS_CODE_DUP_MATCHED);</span>
                } else {
<span class="nc" id="L449">                    clientPrize.setStatusCode(PrizeLevelDto.STATUS_CODE_DUP_UNMATCHED);</span>
                }
            } else {
<span class="nc bnc" id="L452" title="All 2 branches missed.">                if (!matched) {</span>
<span class="nc" id="L453">                    resultDto.getPayouts().add(clientPrize);</span>
<span class="nc" id="L454">                    clientPrize.setStatusCode(PrizeLevelDto.STATUS_CODE_UNMATCHED);</span>
                }
            }
<span class="nc" id="L457">        }</span>
<span class="nc" id="L458">        return resultDto;</span>
    }

    // ----------------------------------------------------------
    // HELPER METHODS
    // ----------------------------------------------------------

    private PrizeLevelDto doValidate(Context ctx, PrizeLevelDto payoutDto) throws ApplicationException {
<span class="fc" id="L466">        InstantTicket ticket = payoutDto.getTicket();</span>
        // check whether client needs to input actual amount
<span class="fc" id="L468">        SysConfiguration sysConf = this.getSysConfigurationDao().getSysConfiguration();</span>
<span class="pc bpc" id="L469" title="2 of 4 branches missed.">        if (sysConf.isNeedInputAmount() &amp;&amp; payoutDto.getClientPrizeAmount() == null) {</span>
<span class="nc" id="L470">            throw new ApplicationException(SystemException.CODE_NO_ACTUALAMOUNT,</span>
                    &quot;No actual amount is specified, please input prize amount for &quot; + &quot;ticket(serialNo=&quot;
                            + ticket.getSerialNo() + &quot;).&quot;);
        }

<span class="fc" id="L475">        InstantTicket hostTicket = this.getInstantTicketDao().getBySerialNo(ticket.getSerialNo());</span>
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">        if (hostTicket == null) {</span>
<span class="nc" id="L477">            throw new ApplicationException(SystemException.CODE_NO_IG_TICKET_FOUND,</span>
                    &quot;can NOT find instant ticket with serialNO=&quot; + ticket.getSerialNo());
        }
<span class="fc" id="L480">        hostTicket.setTransaction(ticket.getTransaction());</span>
<span class="fc" id="L481">        hostTicket.setRawSerialNo(false, ticket.getRawSerialNo());</span>
        // check whether the ticket is damaged
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">        if (InstantTicket.PHYSICAL_STATUS_DAMAGED == hostTicket.getPhysicalStatus()) {</span>
<span class="nc" id="L484">            throw new ApplicationException(SystemException.CODE_ONE_DAMAGETICKET, &quot;Ticket(serialNo=&quot;</span>
                    + hostTicket.getSerialNo() + &quot;) is damaged.&quot;);
        }
<span class="fc bfc" id="L487" title="All 2 branches covered.">        if (InstantTicket.STATUS_VALIDATED == hostTicket.getStatus()) {</span>
<span class="fc" id="L488">            throw new ApplicationException(SystemException.CODE_VALIDATE_REPEAT, &quot;Ticket(serialNO=&quot;</span>
                    + ticket.getSerialNo() + &quot;) has been validated, can NOT validate it again.&quot;);
        }
        // check the status of ticket
<span class="fc bfc" id="L492" title="All 2 branches covered.">        if (InstantTicket.STATUS_ACTIVE != hostTicket.getStatus()) {</span>
<span class="fc" id="L493">            throw new ApplicationException(SystemException.CODE_VALIDATE_NOACTIVETICKET, &quot;Ticket(serialNo=&quot;</span>
                    + ticket.getSerialNo() + &quot;,status=&quot; + hostTicket.getStatus()
                    + &quot;) isn't active, can NOT validate it.&quot;);
        }
<span class="fc" id="L497">        this.verifyBlacklist(hostTicket);</span>
        // check if the ticket is payout blocked
<span class="fc" id="L499">        InstantGameDraw gameDraw = hostTicket.getGameDraw();</span>
        // check status of game
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">        if (Game.STATUS_ACTIVE != gameDraw.getGame().getState()) {</span>
<span class="nc" id="L502">            throw new ApplicationException(SystemException.CODE_GAME_INACTIVE, &quot;Game(id=&quot; + gameDraw.getGame().getId()</span>
                    + &quot;) isn't active.&quot;);
        }
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">        if (gameDraw.getIsSuspendPayoutBlocked() == 1) {</span>
<span class="nc" id="L506">            throw new ApplicationException(SystemException.CODE_DRAW_NOTPAYOUTSTARTED, &quot;Instant ticket(id=&quot;</span>
                    + hostTicket.getId() + &quot;) is payout blocked.&quot;);
        }
        // check stop payout time 'Stop payout time' is not necessary when
        // create a new game. The reason is actual 'Stop payout time' really
        // depends on game sales, its popularity, so usually no one can foresee
        // a 'stop payout time' at the moment of game creation
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">        if (gameDraw.getStopPayoutTime() != null) {</span>
<span class="fc" id="L514">            Date current = new Date();</span>
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">            if (current.after(gameDraw.getStopPayoutTime())) {</span>
<span class="nc" id="L516">                throw new ApplicationException(SystemException.CODE_AFTER_STOPPAYOUTIME,</span>
                        &quot;Current time is after stop payout time of instant game draw(id=&quot; + gameDraw.getId()
                                + &quot;), can NOT validate ticket(serialNo=&quot; + hostTicket.getSerialNo() + &quot;).&quot;);
            }
        }
        // check whether the game instance name is same with GGG in ticket
        // serial
<span class="fc" id="L523">        InstantTicketSerialNo no = new InstantTicketSerialNo(BaseTicket.descryptSerialNo(hostTicket.getSerialNo()));</span>
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">        if (!no.getGGG().equals(hostTicket.getGameDraw().getName())) {</span>
<span class="nc" id="L525">            throw new ApplicationException(SystemException.CODE_WRONGFORMAT_SERIALNO, &quot;The GGG(&quot; + no.getGGG()</span>
                    + &quot;) in ticket serialNo(&quot; + hostTicket.getSerialNo() + &quot;) isn't same with game instance name(&quot;
                    + hostTicket.getGameDraw().getName() + &quot;).&quot;);
        }

<span class="fc" id="L530">        PrizeLevelDto prize = this.getValidationStrategy().validate(hostTicket, ticket.getTicketXOR3(), false);</span>
<span class="fc" id="L531">        prize.setTicket(hostTicket);</span>
<span class="fc" id="L532">        prize.calculateAmount();</span>
        // compare the actual amount
<span class="pc bpc" id="L534" title="2 of 4 branches missed.">        if (sysConf.isNeedInputAmount() &amp;&amp; payoutDto.getClientPrizeAmount().compareTo(prize.getPrizeAmount()) != 0) {</span>
<span class="nc" id="L535">            throw new ApplicationException(SystemException.CODE_NOTMATCH_ACTUALAMOUNT,</span>
                    &quot;Client input wrong prize amount for ticket(serialNo=&quot; + ticket.getSerialNo() + &quot;), host:&quot;
                            + prize.getPrizeAmount() + &quot;, client:&quot; + payoutDto.getClientPrizeAmount());
        }

        // if the winning algorithm is eGame, then this operation must check
        // whether the merchant has privilege to perform payout of winning
        // levels...prize group checking
<span class="fc bfc" id="L543" title="All 2 branches covered.">        if (hostTicket.getGameDraw().getValidationType() == InstantGameDraw.VALIDATION_TYPE_EGAME) {</span>
<span class="fc" id="L544">            int gameType = hostTicket.getGameDraw().getGame().getType();</span>
<span class="fc" id="L545">            Set&lt;Integer&gt; levels = new HashSet&lt;Integer&gt;();</span>
<span class="fc" id="L546">            levels.add(prize.getPrizeLevel());</span>
<span class="fc" id="L547">            this.getMerchantService().allowPayout(</span>
                    ctx,
                    hostTicket.getGameDraw().getGame(),
                    new PayoutLevelAllowRequest[] { new PayoutLevelAllowRequest(levels, gameType,
                            PrizeGroupItem.GROUP_TYPE_IG) }, prize.getActualAmount());
<span class="fc" id="L552">        } else {</span>
<span class="fc" id="L553">            this.getMerchantService().allowPayout(ctx, hostTicket.getGameDraw().getGame(), null,</span>
                    prize.getActualAmount());
        }

        // ------------------------------------------------------------
        // NOTE: the above statements are checking the pre-condition of
        // validation, you can NOT update any entity there. Due to batch
        // validation will invoke this method, if fail to validate one ticket,
        // the
        // modification will be committed...In fact, this transaction (one
        // ticket validation) should be roll-back.
        // ------------------------------------------------------------

        // set gameId
<span class="fc" id="L567">        ticket.getTransaction().setGameId(gameDraw.getGame().getId());</span>
        // update VIRN prize
<span class="fc bfc" id="L569" title="All 2 branches covered.">        if (prize.getVirnPrize() != null) {</span>
<span class="fc" id="L570">            prize.getVirnPrize().setValidated(true);</span>
<span class="fc" id="L571">            this.getInstantVIRNPrizeDao().update(prize.getVirnPrize());</span>
        }

        // update prize level for later reference if the validation algorithm is
        // 'VIRN', save VIRN to InstantTicket.ticketXOR3... 'reversal'
        // transaction will need this information set VIRN to ticketXOR3
<span class="fc" id="L577">        hostTicket.setTicketXOR3(ticket.getTicketXOR3());</span>
<span class="fc" id="L578">        hostTicket.setStatus(InstantTicket.STATUS_VALIDATED);</span>
<span class="fc" id="L579">        hostTicket.setPrizeLevel(prize.getPrizeLevel());</span>
<span class="fc" id="L580">        hostTicket.setPrizeAmount(prize.getPrizeAmount());</span>
<span class="fc" id="L581">        hostTicket.setTaxAmount(prize.getTaxAmount());</span>
<span class="fc" id="L582">        this.getInstantTicketDao().update(hostTicket);</span>

        // update prize_win_count, JPA runtime will merge it automatically when
        // commit.
<span class="fc" id="L586">        prize.setNumberOfWinner(prize.getNumberOfWinner() + 1);</span>

<span class="fc" id="L588">        this.generatePayout(hostTicket, prize);</span>

        // restore credit...only count cash amount
<span class="fc" id="L591">        BigDecimal creditAmount = prize.getCashActualAmount();</span>
<span class="fc" id="L592">        ticket.getTransaction().setTotalAmount(creditAmount);</span>
<span class="fc" id="L593">        Object updatedOperator = this.getCreditService().credit(ticket.getTransaction().getOperatorId(),</span>
                ticket.getTransaction().getMerchantId(), creditAmount, hostTicket.getGameDraw().getGame().getId(),
                true, false, false, ticket.getTransaction());

        // 鏄惁璁＄畻浣ｉ噾
<span class="pc bpc" id="L598" title="2 of 4 branches missed.">        if (MLotteryContext.getInstance().getSysConfiguration().isSupportCommissionCalculation()</span>
                &amp;&amp; ctx.getTransaction().getType() == TransactionType.VALIDATE_INSTANT_TICKET.getRequestType()) {
<span class="fc" id="L600">            BalanceTransactions tempBalanceTransactions = new Gson().fromJson(ticket.getTransaction().getTransMessage()</span>
                    .getRequestMsg(), BalanceTransactions.class);
<span class="fc" id="L602">            BalanceTransactions operatorBalanceTransactions = balanceTransactionsDao.assembleBalanceTransactions(ctx,</span>
                    creditAmount);
<span class="fc" id="L604">            operatorBalanceTransactions.setCommissionAmount(tempBalanceTransactions.getCommissionAmount());</span>
<span class="fc" id="L605">            operatorBalanceTransactions.setCommissionRate(tempBalanceTransactions.getCommissionRate());</span>
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">            if (updatedOperator == null) {</span>
<span class="nc" id="L607">                throw new SystemException(SystemException.CODE_OPERATOR_TOPUP_IGNORED, &quot;THe payout to operator(id=&quot;</span>
                        + ticket.getOperatorId() + &quot; will be ignored.&quot;);
            } else {
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">                if (updatedOperator instanceof Merchant) {</span>
<span class="nc" id="L611">                    Merchant merchant = (Merchant) updatedOperator;</span>
<span class="nc" id="L612">                    BalanceTransactions merchantBalanceTransactions = balanceTransactionsDao</span>
                            .assembleBalanceTransactions(ctx, creditAmount);
<span class="nc" id="L614">                    merchantBalanceTransactions.setOwnerId(String.valueOf(merchant.getId()));</span>
<span class="nc" id="L615">                    merchantBalanceTransactions.setOwnerType(BalanceTransactions.OWNER_TYPE_MERCHANT);</span>
<span class="nc" id="L616">                    balanceTransactionsDao.insert(merchantBalanceTransactions);</span>
                }
            }
<span class="fc" id="L619">            balanceTransactionsDao.insert(operatorBalanceTransactions);</span>
        }

<span class="fc" id="L622">        return prize;</span>
    }

    private void verifyBlacklist(InstantTicket hostTicket) throws ApplicationException {
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">        if (hostTicket.isInBlacklist()) {</span>
<span class="nc" id="L627">            throw new ApplicationException(SystemException.CODE_TICKET_INBLACKLIST, &quot;Instant ticket(serialNo=&quot;</span>
                    + hostTicket.getSerialNo() + &quot;) is in blacklist, it will be blocked.&quot;);
        }
<span class="fc" id="L630">    }</span>

    /**
     * Assemble payout from a instant ticket.
     */
    private void generatePayout(InstantTicket hostTicket, PrizeLevelDto payoutDto) throws ApplicationException {
        // GENERATE PAYOUT
<span class="fc" id="L637">        Payout payout = new Payout();</span>
<span class="fc" id="L638">        payout.setCreateTime(new Date());</span>
<span class="fc" id="L639">        payout.setId(this.getUuidManager().getGeneralID());</span>
<span class="fc" id="L640">        payout.setStatus(Payout.STATUS_PAID);</span>
<span class="fc" id="L641">        payout.setTicketSerialNo(hostTicket.getSerialNo());</span>
        // set after-tax prize amount to Payout
        // if prize.getTaxAmount() is null, it means no tax for this prize.
        // payout.setTotalAmount(payoutDto.getPrizeAmount().subtract(payoutDto.getTaxAmount()));
        // payout.setBeforeTaxTotalAmount(payoutDto.getPrizeAmount());
<span class="fc" id="L646">        payout.setTotalAmount(payoutDto.getCashActualAmount());</span>
<span class="fc" id="L647">        payout.setBeforeTaxTotalAmount(payoutDto.getCashPrizeAmount());</span>
<span class="fc" id="L648">        payout.setBeforeTaxObjectAmount(payoutDto.getPrizeAmount().subtract(payoutDto.getCashPrizeAmount()));</span>
<span class="fc" id="L649">        payout.setNumberOfObject(payoutDto.getNumberOfObject());</span>
<span class="fc" id="L650">        payout.setTransaction(hostTicket.getTransaction());</span>
<span class="fc" id="L651">        payout.setInputChannel(payoutDto.getInputChannel());</span>
<span class="fc" id="L652">        payout.setType(Payout.TYPE_WINNING);</span>
<span class="fc" id="L653">        payout.setValid(true);</span>

<span class="fc" id="L655">        payout.setOperatorId(hostTicket.getTransaction().getOperatorId());</span>
<span class="fc" id="L656">        payout.setMerchantId((int) hostTicket.getTransaction().getMerchantId());</span>
<span class="fc" id="L657">        payout.setDevId((int) hostTicket.getTransaction().getDeviceId());</span>
<span class="fc" id="L658">        payout.setGameInstanceId(hostTicket.getGameDraw().getId());</span>
<span class="fc" id="L659">        payout.setGameId(hostTicket.getGameDraw().getGame().getId());</span>

<span class="fc" id="L661">        this.getPayoutDao().insert(payout);</span>

        // GENERATE PAYOUT_DETAIL
<span class="fc bfc" id="L664" title="All 2 branches covered.">        for (PrizeLevelItemDto prizeItem : payoutDto.getLevelItems()) {</span>
<span class="fc" id="L665">            PayoutDetail payoutDetail = new PayoutDetail();</span>
<span class="fc" id="L666">            payoutDetail.setId(this.getUuidManager().getGeneralID());</span>
<span class="fc" id="L667">            payoutDetail.setPayoutId(payout.getId());</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">            if (PrizeLevelDto.PRIZE_TYPE_OBJECT == prizeItem.getPrizeType()) {</span>
<span class="fc" id="L669">                payoutDetail.setObjectId(prizeItem.getObjectId());</span>
<span class="fc" id="L670">                payoutDetail.setObjectName(prizeItem.getObjectName());</span>
            }
            // set prize_amount to total_amount
<span class="fc" id="L673">            payoutDetail.setPrizeAmount(prizeItem.getPrizeAmount());</span>
            // set actual_amount to cash_amount
<span class="fc" id="L675">            payoutDetail.setActualAmount(prizeItem.getActualAmount());</span>
<span class="fc" id="L676">            payoutDetail.setNumberOfObject(prizeItem.getNumberOfObject());</span>
<span class="fc" id="L677">            payoutDetail.setPayoutType(prizeItem.getPrizeType());</span>
<span class="fc" id="L678">            payoutDetail.setUpdateTime(new Date());</span>
<span class="fc" id="L679">            payoutDetail.setCreateTime(new Date());</span>
<span class="fc" id="L680">            payoutDetail.setCreateBy(payout.getOperatorId());</span>
<span class="fc" id="L681">            payoutDetail.setUpdateBy(payout.getOperatorId());</span>
<span class="fc" id="L682">            this.getPayoutDetailDao().insert(payoutDetail);</span>
<span class="fc" id="L683">        }</span>
<span class="fc" id="L684">    }</span>

    // ----------------------------------------------------------
    // SPRING DEPENDENCIES INJECTION
    // ----------------------------------------------------------

    public InstantTicketDao getInstantTicketDao() {
<span class="fc" id="L691">        return instantTicketDao;</span>
    }

    public void setInstantTicketDao(InstantTicketDao instantTicketDao) {
<span class="fc" id="L695">        this.instantTicketDao = instantTicketDao;</span>
<span class="fc" id="L696">    }</span>

    public UUIDService getUuidManager() {
<span class="fc" id="L699">        return uuidManager;</span>
    }

    public void setUuidManager(UUIDService uuidManager) {
<span class="fc" id="L703">        this.uuidManager = uuidManager;</span>
<span class="fc" id="L704">    }</span>

    public PayoutDao getPayoutDao() {
<span class="fc" id="L707">        return payoutDao;</span>
    }

    public void setPayoutDao(PayoutDao payoutDao) {
<span class="fc" id="L711">        this.payoutDao = payoutDao;</span>
<span class="fc" id="L712">    }</span>

    public ValidationStrategy getValidationStrategy() {
<span class="fc" id="L715">        return validationStrategy;</span>
    }

    public void setValidationStrategy(ValidationStrategy validationStrategy) {
<span class="fc" id="L719">        this.validationStrategy = validationStrategy;</span>
<span class="fc" id="L720">    }</span>

    public MerchantService getMerchantService() {
<span class="fc" id="L723">        return merchantService;</span>
    }

    public void setMerchantService(MerchantService merchantService) {
<span class="fc" id="L727">        this.merchantService = merchantService;</span>
<span class="fc" id="L728">    }</span>

    public CriteriaActiveStrategy getCriteriaActiveStrategy() {
<span class="fc" id="L731">        return criteriaActiveStrategy;</span>
    }

    public void setCriteriaActiveStrategy(CriteriaActiveStrategy criteriaActiveStrategy) {
<span class="fc" id="L735">        this.criteriaActiveStrategy = criteriaActiveStrategy;</span>
<span class="fc" id="L736">    }</span>

    public SysConfigurationDao getSysConfigurationDao() {
<span class="fc" id="L739">        return sysConfigurationDao;</span>
    }

    public void setSysConfigurationDao(SysConfigurationDao sysConfigurationDao) {
<span class="fc" id="L743">        this.sysConfigurationDao = sysConfigurationDao;</span>
<span class="fc" id="L744">    }</span>

    public InstantVIRNPrizeDao getInstantVIRNPrizeDao() {
<span class="fc" id="L747">        return instantVIRNPrizeDao;</span>
    }

    public void setInstantVIRNPrizeDao(InstantVIRNPrizeDao instantVIRNPrizeDao) {
<span class="fc" id="L751">        this.instantVIRNPrizeDao = instantVIRNPrizeDao;</span>
<span class="fc" id="L752">    }</span>

    public PrizeObjectDao getPrizeObjectDao() {
<span class="nc" id="L755">        return prizeObjectDao;</span>
    }

    public void setPrizeObjectDao(PrizeObjectDao prizeObjectDao) {
<span class="nc" id="L759">        this.prizeObjectDao = prizeObjectDao;</span>
<span class="nc" id="L760">    }</span>

    public PayoutDetailDao getPayoutDetailDao() {
<span class="fc" id="L763">        return payoutDetailDao;</span>
    }

    public void setPayoutDetailDao(PayoutDetailDao payoutDetailDao) {
<span class="fc" id="L767">        this.payoutDetailDao = payoutDetailDao;</span>
<span class="fc" id="L768">    }</span>

    public CreditService getCreditService() {
<span class="fc" id="L771">        return creditService;</span>
    }

    public void setCreditService(CreditService creditService) {
<span class="fc" id="L775">        this.creditService = creditService;</span>
<span class="fc" id="L776">    }</span>

    public IGBatchReportDao getiGBatchReportDao() {
<span class="fc" id="L779">        return iGBatchReportDao;</span>
    }

    public void setiGBatchReportDao(IGBatchReportDao iGBatchReportDao) {
<span class="fc" id="L783">        this.iGBatchReportDao = iGBatchReportDao;</span>
<span class="fc" id="L784">    }</span>

    public IGFailedTicketsReportDao getiGFailedTicketsReportDao() {
<span class="fc" id="L787">        return iGFailedTicketsReportDao;</span>
    }

    public void setiGFailedTicketsReportDao(IGFailedTicketsReportDao iGFailedTicketsReportDao) {
<span class="fc" id="L791">        this.iGFailedTicketsReportDao = iGFailedTicketsReportDao;</span>
<span class="fc" id="L792">    }</span>

    public IGPayoutDetailTempDao getiGPayoutDetailTempDao() {
<span class="fc" id="L795">        return iGPayoutDetailTempDao;</span>
    }

    public void setiGPayoutDetailTempDao(IGPayoutDetailTempDao iGPayoutDetailTempDao) {
<span class="fc" id="L799">        this.iGPayoutDetailTempDao = iGPayoutDetailTempDao;</span>
<span class="fc" id="L800">    }</span>

    public IGPayoutTempDao getiGPayoutTempDao() {
<span class="fc" id="L803">        return iGPayoutTempDao;</span>
    }

    public void setiGPayoutTempDao(IGPayoutTempDao iGPayoutTempDao) {
<span class="fc" id="L807">        this.iGPayoutTempDao = iGPayoutTempDao;</span>
<span class="fc" id="L808">    }</span>

    public ConfirmBatchPayoutDto partialPackage(Context response, ConfirmBatchPayoutDto confirmBatchPayout)
            throws ApplicationException {

        // TODO Auto-generated method stub
<span class="fc" id="L814">        ConfirmBatchPayoutDto dto = new ConfirmBatchPayoutDto();</span>
<span class="fc" id="L815">        boolean isSamePrizeType = true;</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">        for (PrizeLevelDto payout : confirmBatchPayout.getPayouts()) {</span>
<span class="fc" id="L817">            PrizeLevelDto prizeLevel = null;</span>
            // it's in processing by another operators
<span class="fc" id="L819">            InstantTicket ticket = payout.getTicket();</span>

            try {
                // 1,a ticket cannot be able to do validation when it's in
                // processing

                // 1,if a ticket has been handled ,will be skip
<span class="fc" id="L826">                IGPayoutTemp oldPayoutTemp = this.getiGPayoutTempDao().getPayoutTempByCondition(</span>
                        confirmBatchPayout.getBatchNumber(), ticket.getOperatorId(), ticket.getSerialNo());

<span class="pc bpc" id="L829" title="1 of 2 branches missed.">                if (oldPayoutTemp != null) {</span>
                    // skip to handle current ticket
                } else {
                    // 2,a ticket cannot be able to do confirm batch validation
                    // when
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">                    if (!this.getiGPayoutTempDao().isUsedByAnotherOperatorId(ticket.getOperatorId(),</span>
                            ticket.getSerialNo())) {

<span class="fc" id="L837">                        prizeLevel = this.doTemporayValidate(response, payout, confirmBatchPayout.getBatchNumber(),</span>
                                true);

                        // all successful validations must be same prize
                        // type...WHY???
                        // disable it!
                        // if (prizeType == null)
                        // prizeType = result.getPrizeType() + &quot;&quot;;
                        // else if (!prizeType.equals(result.getPrizeType())) {
                        // isSamePrizeType = false;
                        // break;
                        // }
                        // assemble result
<span class="fc" id="L850">                        dto.setActualAmount(dto.getActualAmount().add(prizeLevel.getActualAmount()));</span>
<span class="fc" id="L851">                        dto.setTaxAmount(dto.getTaxAmount().add(prizeLevel.getTaxAmount()));</span>
<span class="fc" id="L852">                        dto.setTotalSuccess(dto.getTotalSuccess() + 1);</span>
                    } else {
                        // this tickets is failed,need to add it to failed
                        // ticket table

                        // failedReport.setBatchId(confirmBatchPayout.getBatchNumber());
                        // failedReport.setIgSerialNumber(ticket.getSerialNo());
                        // failedReport.setOperatorId(ticket.getOperatorId());
<span class="nc" id="L860">                        this.createFailedTicketData(SystemException.CODE_TICKET_IS_USING_BY_OTHER_OPERATOR,</span>
                                confirmBatchPayout.getBatchNumber(), ticket.getSerialNo(), response.getOperatorId());
                    }
                }
            }
            // one failed validation shouldn't affect other tickets
<span class="fc" id="L866">            catch (ApplicationException e) { // can and ONLY can handle</span>
                                             // ApplicationException
                                             // write log
<span class="fc" id="L869">                logger.warn(e.getMessage(), e);</span>
<span class="pc bpc" id="L870" title="1 of 2 branches missed.">                if (prizeLevel == null) {</span>
<span class="fc" id="L871">                    prizeLevel = new PrizeLevelDto();</span>
                }
<span class="fc" id="L873">                prizeLevel.setErrorCode(e.getErrorCode());</span>
<span class="fc" id="L874">                prizeLevel.setTicket(payout.getTicket());</span>
<span class="fc" id="L875">                dto.setTotalFail(dto.getTotalFail() + 1);</span>
<span class="fc" id="L876">                this.createFailedTicketData(e.getErrorCode(), confirmBatchPayout.getBatchNumber(),</span>
                        ticket.getSerialNo(), response.getOperatorId());
<span class="fc" id="L878">            }</span>
<span class="pc bpc" id="L879" title="1 of 2 branches missed.">            if (prizeLevel != null) {</span>
<span class="fc" id="L880">                dto.getPayouts().add(prizeLevel);</span>
            }

<span class="pc bpc" id="L883" title="1 of 2 branches missed.">            if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L884">                logger.debug(&quot;Finish handling validate ticket(serialNo=&quot; + payout.getTicket().getSerialNo() + &quot;):&quot;</span>
                        + payout.toString());
            }
<span class="fc" id="L887">        }</span>
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">        if (!isSamePrizeType) {</span>
<span class="nc" id="L889">            throw new ApplicationException(SystemException.CODE_BATCH_VALIDATION_NOT_SAME_TYPE,</span>
                    &quot;the prize type of all successful validation must be same type.&quot;);
        }
<span class="fc" id="L892">        return dto;</span>
    }

    private void createFailedTicketData(int errorCode, long batchNumber, String serialNo, String operatorId)
            throws ApplicationException {

<span class="fc" id="L898">        IGFailedTicketsReport failedReport = new IGFailedTicketsReport();</span>
<span class="fc" id="L899">        failedReport.setBatchId(batchNumber);</span>
<span class="fc" id="L900">        failedReport.setIgSerialNumber(serialNo);</span>
<span class="fc" id="L901">        failedReport.setOperatorId(operatorId);</span>
<span class="fc" id="L902">        failedReport.setStatus(Constants.YES);</span>
<span class="fc" id="L903">        failedReport.setCreateTime(new Date());</span>
<span class="fc" id="L904">        failedReport.setUpdateTime(new Date());</span>
<span class="fc" id="L905">        failedReport.setId(this.getUuidManager().getGeneralID());</span>
<span class="fc" id="L906">        failedReport.setErrorCode(errorCode);</span>

<span class="fc" id="L908">        this.getiGFailedTicketsReportDao().insert(failedReport);</span>
        // failedReport=this.getiGFailedTicketsReportDao().findById(IGFailedTicketsReport.class,
        // failedReport.getId());
<span class="fc" id="L911">    }</span>

    /**
     * Need to complete validation temporarily for confirmation batch validation with a same batch number.
     */
    private PrizeLevelDto doTemporayValidate(Context ctx, PrizeLevelDto payoutDto, long batchNumber,
            boolean isIngoreCheckingAmount) throws ApplicationException {
<span class="fc" id="L918">        InstantTicket ticket = payoutDto.getTicket();</span>

        // check whether client needs to input actual amount
<span class="fc" id="L921">        SysConfiguration sysConf = this.getSysConfigurationDao().getSysConfiguration();</span>
<span class="pc bpc" id="L922" title="5 of 6 branches missed.">        if (!isIngoreCheckingAmount &amp;&amp; sysConf.isNeedInputAmount() &amp;&amp; payoutDto.getClientPrizeAmount() == null) {</span>
<span class="nc" id="L923">            throw new ApplicationException(SystemException.CODE_NO_ACTUALAMOUNT,</span>
                    &quot;No actual amount is specified, please input prize amount for &quot; + &quot;ticket(serialNo=&quot;
                            + ticket.getSerialNo() + &quot;).&quot;);
        }

<span class="fc" id="L928">        InstantTicket hostTicket = this.getInstantTicketDao().getBySerialNo(ticket.getSerialNo());</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">        if (hostTicket == null) {</span>
<span class="fc" id="L930">            throw new ApplicationException(SystemException.CODE_NO_IG_TICKET_FOUND,</span>
                    &quot;can NOT find instant ticket with serialNO=&quot; + ticket.getSerialNo());
        }
        // TODO: need to hidden this ???????????????????
<span class="fc" id="L934">        hostTicket.setTransaction(ticket.getTransaction());// need to notify</span>

<span class="fc" id="L936">        hostTicket.setRawSerialNo(false, ticket.getRawSerialNo());</span>
        // check whether the ticket is damaged
<span class="pc bpc" id="L938" title="1 of 2 branches missed.">        if (InstantTicket.PHYSICAL_STATUS_DAMAGED == hostTicket.getPhysicalStatus()) {</span>
<span class="nc" id="L939">            throw new ApplicationException(SystemException.CODE_ONE_DAMAGETICKET, &quot;Ticket(serialNo=&quot;</span>
                    + hostTicket.getSerialNo() + &quot;) is damaged.&quot;);
        }
<span class="pc bpc" id="L942" title="1 of 2 branches missed.">        if (InstantTicket.STATUS_VALIDATED == hostTicket.getStatus()) {</span>
<span class="nc" id="L943">            throw new ApplicationException(SystemException.CODE_VALIDATE_REPEAT, &quot;Ticket(serialNO=&quot;</span>
                    + ticket.getSerialNo() + &quot;) has been validated, can NOT validate it again.&quot;);
        }
        // check the status of ticket
<span class="pc bpc" id="L947" title="2 of 4 branches missed.">        if (InstantTicket.STATUS_ACTIVE != hostTicket.getStatus()</span>
                || InstantTicket.STATUS_PROCESSING == hostTicket.getStatus()) {
<span class="nc" id="L949">            throw new ApplicationException(SystemException.CODE_VALIDATE_NOACTIVETICKET, &quot;Ticket(serialNo=&quot;</span>
                    + ticket.getSerialNo() + &quot;,status=&quot; + hostTicket.getStatus()
                    + &quot;) isn't active, can NOT validate it.&quot;);
        }
<span class="fc" id="L953">        this.verifyBlacklist(hostTicket);</span>
        // check if the ticket is payout blocked
<span class="fc" id="L955">        InstantGameDraw gameDraw = hostTicket.getGameDraw();</span>
        // check status of game
<span class="pc bpc" id="L957" title="1 of 2 branches missed.">        if (Game.STATUS_ACTIVE != gameDraw.getGame().getState()) {</span>
<span class="nc" id="L958">            throw new ApplicationException(SystemException.CODE_GAME_INACTIVE, &quot;Game(id=&quot; + gameDraw.getGame().getId()</span>
                    + &quot;) isn't active.&quot;);
        }
<span class="pc bpc" id="L961" title="1 of 2 branches missed.">        if (gameDraw.getIsSuspendPayoutBlocked() == 1) {</span>
<span class="nc" id="L962">            throw new ApplicationException(SystemException.CODE_DRAW_NOTPAYOUTSTARTED, &quot;Instant ticket(id=&quot;</span>
                    + hostTicket.getId() + &quot;) is payout blocked.&quot;);
        }
        // check stop payout time 'Stop payout time' is not necessary when
        // create a new game. The reason is actual 'Stop payout time' really
        // depends on game sales, its popularity, so usually no one can foresee
        // a 'stop payout time' at the moment of game creation
<span class="pc bpc" id="L969" title="1 of 2 branches missed.">        if (gameDraw.getStopPayoutTime() != null) {</span>
<span class="fc" id="L970">            Date current = new Date();</span>
<span class="pc bpc" id="L971" title="1 of 2 branches missed.">            if (current.after(gameDraw.getStopPayoutTime())) {</span>
<span class="nc" id="L972">                throw new ApplicationException(SystemException.CODE_AFTER_STOPPAYOUTIME,</span>
                        &quot;Current time is after stop payout time of instant game draw(id=&quot; + gameDraw.getId()
                                + &quot;), can NOT validate ticket(serialNo=&quot; + hostTicket.getSerialNo() + &quot;).&quot;);
            }
        }
        // check whether the game instance name is same with GGG in ticket
        // serial
<span class="fc" id="L979">        InstantTicketSerialNo no = new InstantTicketSerialNo(BaseTicket.descryptSerialNo(hostTicket.getSerialNo()));</span>
<span class="pc bpc" id="L980" title="1 of 2 branches missed.">        if (!no.getGGG().equals(hostTicket.getGameDraw().getName())) {</span>
<span class="nc" id="L981">            throw new ApplicationException(SystemException.CODE_WRONGFORMAT_SERIALNO, &quot;The GGG(&quot; + no.getGGG()</span>
                    + &quot;) in ticket serialNo(&quot; + hostTicket.getSerialNo() + &quot;) isn't same with game instance name(&quot;
                    + hostTicket.getGameDraw().getName() + &quot;).&quot;);
        }

<span class="fc" id="L986">        PrizeLevelDto prize = this.getValidationStrategy().validate(hostTicket, ticket.getTicketXOR3(), false);</span>

<span class="fc" id="L988">        prize.setTicket(hostTicket);</span>
<span class="fc" id="L989">        prize.calculateAmount();</span>
        // compare the actual amount
<span class="pc bpc" id="L991" title="5 of 6 branches missed.">        if (!isIngoreCheckingAmount &amp;&amp; sysConf.isNeedInputAmount()</span>
                &amp;&amp; payoutDto.getClientPrizeAmount().compareTo(prize.getPrizeAmount()) != 0) {
<span class="nc" id="L993">            throw new ApplicationException(SystemException.CODE_NOTMATCH_ACTUALAMOUNT,</span>
                    &quot;Client input wrong prize amount for ticket(serialNo=&quot; + ticket.getSerialNo() + &quot;), host:&quot;
                            + prize.getPrizeAmount() + &quot;, client:&quot; + payoutDto.getClientPrizeAmount());
        }

        // if the winning algorithm is eGame, then this operation must check
        // whether the merchant has privilege to perform payout of winning
        // levels...prize group checking
<span class="pc bpc" id="L1001" title="1 of 2 branches missed.">        if (hostTicket.getGameDraw().getValidationType() == InstantGameDraw.VALIDATION_TYPE_EGAME) {</span>
<span class="nc" id="L1002">            int gameType = hostTicket.getGameDraw().getGame().getType();</span>
<span class="nc" id="L1003">            Set&lt;Integer&gt; levels = new HashSet&lt;Integer&gt;();</span>
<span class="nc" id="L1004">            levels.add(prize.getPrizeLevel());</span>
<span class="nc" id="L1005">            this.getMerchantService().allowPayout(</span>
                    ctx,
                    hostTicket.getGameDraw().getGame(),
                    new PayoutLevelAllowRequest[] { new PayoutLevelAllowRequest(levels, gameType,
                            PrizeGroupItem.GROUP_TYPE_IG) }, prize.getActualAmount());
<span class="nc" id="L1010">        } else {</span>
<span class="fc" id="L1011">            this.getMerchantService().allowPayout(ctx, hostTicket.getGameDraw().getGame(), null,</span>
                    prize.getActualAmount());
        }

        // ------------------------------------------------------------
        // NOTE: the above statements are checking the pre-condition of
        // validation, you can NOT update any entity there. Due to batch
        // validation will invoke this method, if fail to validate one ticket,
        // the
        // modification will be committed...In fact, this transaction (one
        // ticket validation) should be roll-back.
        // ------------------------------------------------------------

        // set gameId
<span class="fc" id="L1025">        ticket.getTransaction().setGameId(gameDraw.getGame().getId());</span>
        // update VIRN prize
<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">        if (prize.getVirnPrize() != null) {</span>
<span class="fc" id="L1028">            prize.getVirnPrize().setValidated(true);</span>
<span class="fc" id="L1029">            this.getInstantVIRNPrizeDao().update(prize.getVirnPrize());</span>
        }

        // update prize level for later reference if the validation algorithm is
        // 'VIRN', save VIRN to InstantTicket.ticketXOR3... 'reversal'
        // transaction will need this information set VIRN to ticketXOR3
<span class="fc" id="L1035">        hostTicket.setTicketXOR3(ticket.getTicketXOR3());</span>
        // need set status to process
<span class="fc" id="L1037">        hostTicket.setStatus(InstantTicket.STATUS_PROCESSING);</span>
<span class="fc" id="L1038">        hostTicket.setPrizeLevel(prize.getPrizeLevel());</span>
<span class="fc" id="L1039">        hostTicket.setPrizeAmount(prize.getPrizeAmount());</span>
<span class="fc" id="L1040">        hostTicket.setTaxAmount(prize.getTaxAmount());</span>

<span class="fc" id="L1042">        this.getInstantTicketDao().update(hostTicket);</span>

        // update prize_win_count, JPA runtime will merge it autlmatically when
        // commit.
<span class="fc" id="L1046">        prize.setNumberOfWinner(prize.getNumberOfWinner() + 1);</span>

<span class="fc" id="L1048">        this.generatePayoutTemp(hostTicket, prize, batchNumber);</span>

        // restore credit...only count cash amount
        /* Need to handle in confirmation batch Validation.TODO: */
        /*
         * BigDecimal creditAmount = prize.getCashActualAmount(); this.getCreditService
         * ().credit(ticket.getTransaction().getOperatorId(), ticket.getTransaction().getMerchantId(), creditAmount,
         * hostTicket.getGameDraw().getGame().getId(), true, false, false);
         */

        // need to calculate

<span class="fc" id="L1060">        return prize;</span>
    }

    /**
     * Assemble temp payout from a batch instant ticket.
     */
    private void generatePayoutTemp(InstantTicket hostTicket, PrizeLevelDto payoutDto, long batchNumber)
            throws ApplicationException {
<span class="fc" id="L1068">        boolean isSucceeded = true;</span>
        // check whether the data is existed in DB already,if it's existed,don't
        // need to store it into

        // GENERATE PAYOUT
<span class="fc" id="L1073">        IGPayoutTemp payoutTemp = new IGPayoutTemp();</span>
<span class="fc" id="L1074">        payoutTemp.setCreateTime(new Date());</span>
<span class="fc" id="L1075">        payoutTemp.setId(this.getUuidManager().getGeneralID());</span>
<span class="fc" id="L1076">        payoutTemp.setStatus(Payout.STATUS_PAID);</span>
<span class="fc" id="L1077">        payoutTemp.setTicketSerialNo(hostTicket.getSerialNo());</span>
        // set after-tax prize amount to Payout
        // if prize.getTaxAmount() is null, it means no tax for this prize.
        // payout.setTotalAmount(payoutDto.getPrizeAmount().subtract(payoutDto.getTaxAmount()));
        // payout.setBeforeTaxTotalAmount(payoutDto.getPrizeAmount());
<span class="fc" id="L1082">        payoutTemp.setTotalAmount(payoutDto.getCashActualAmount());</span>
<span class="fc" id="L1083">        payoutTemp.setBeforeTaxTotalAmount(payoutDto.getCashPrizeAmount());</span>
<span class="fc" id="L1084">        payoutTemp.setBeforeTaxObjectAmount(payoutDto.getPrizeAmount().subtract(payoutDto.getCashPrizeAmount()));</span>
<span class="fc" id="L1085">        payoutTemp.setNumberOfObject(payoutDto.getNumberOfObject());</span>
<span class="fc" id="L1086">        payoutTemp.setTransaction(hostTicket.getTransaction());</span>
<span class="fc" id="L1087">        payoutTemp.setInputChannel(payoutDto.getInputChannel());</span>
<span class="fc" id="L1088">        payoutTemp.setType(Payout.TYPE_WINNING);</span>
<span class="fc" id="L1089">        payoutTemp.setValid(true);</span>

<span class="fc" id="L1091">        payoutTemp.setOperatorId(hostTicket.getTransaction().getOperatorId());</span>
<span class="fc" id="L1092">        payoutTemp.setMerchantId((int) hostTicket.getTransaction().getMerchantId());</span>
<span class="fc" id="L1093">        payoutTemp.setDevId((int) hostTicket.getTransaction().getDeviceId());</span>
<span class="fc" id="L1094">        payoutTemp.setGameInstanceId(hostTicket.getGameDraw().getId());</span>
<span class="fc" id="L1095">        payoutTemp.setGameId(hostTicket.getGameDraw().getGame().getId());</span>

<span class="fc" id="L1097">        payoutTemp.setiGBatchNumber(batchNumber);</span>

<span class="fc" id="L1099">        this.getiGPayoutTempDao().insert(payoutTemp);</span>

        // GENERATE PAYOUT_DETAIL
<span class="fc bfc" id="L1102" title="All 2 branches covered.">        for (PrizeLevelItemDto prizeItem : payoutDto.getLevelItems()) {</span>
<span class="fc" id="L1103">            IGPayoutDetailTemp payoutDetailTemp = new IGPayoutDetailTemp();</span>
<span class="fc" id="L1104">            payoutDetailTemp.setId(this.getUuidManager().getGeneralID());</span>
<span class="fc" id="L1105">            payoutDetailTemp.setPayoutId(payoutTemp.getId());</span>
<span class="pc bpc" id="L1106" title="1 of 2 branches missed.">            if (PrizeLevelDto.PRIZE_TYPE_OBJECT == prizeItem.getPrizeType()) {</span>
<span class="nc" id="L1107">                payoutDetailTemp.setObjectId(prizeItem.getObjectId());</span>
<span class="nc" id="L1108">                payoutDetailTemp.setObjectName(prizeItem.getObjectName());</span>
            }
            // set prize_amount to total_amount
<span class="fc" id="L1111">            payoutDetailTemp.setPrizeAmount(prizeItem.getPrizeAmount());</span>
            // set actual_amount to cash_amount
<span class="fc" id="L1113">            payoutDetailTemp.setActualAmount(prizeItem.getActualAmount());</span>
<span class="fc" id="L1114">            payoutDetailTemp.setNumberOfObject(prizeItem.getNumberOfObject());</span>
<span class="fc" id="L1115">            payoutDetailTemp.setPayoutType(prizeItem.getPrizeType());</span>
<span class="fc" id="L1116">            payoutDetailTemp.setUpdateTime(new Date());</span>
<span class="fc" id="L1117">            payoutDetailTemp.setCreateTime(new Date());</span>
<span class="fc" id="L1118">            payoutDetailTemp.setCreateBy(payoutTemp.getOperatorId());</span>
<span class="fc" id="L1119">            payoutDetailTemp.setUpdateBy(payoutTemp.getOperatorId());</span>

<span class="fc" id="L1121">            payoutDetailTemp.setiGBatchNumber(batchNumber);</span>
<span class="fc" id="L1122">            payoutDetailTemp.setOperatorId(payoutTemp.getOperatorId());</span>

<span class="fc" id="L1124">            this.getiGPayoutDetailTempDao().insert(payoutDetailTemp);</span>

<span class="fc" id="L1126">        }</span>
        // return isSucceeded;
<span class="fc" id="L1128">    }</span>

    /**
     * Query the batch upload success and failure votes and return Actual amount ,tax amount.
     */
    @Override
    public InstantBatchReportDto getReportOfConfirmBatchValidation(Context ctx, InstantBatchReportDto dto)
            throws ApplicationException {
<span class="fc" id="L1136">        InstantBatchReportDto instantBatchReportDto = new InstantBatchReportDto();</span>
<span class="fc" id="L1137">        IGBatchReport igBatchReport = iGBatchReportDao.getByBatchId(ctx.getOperatorId(), dto.getBatchNumber());</span>
<span class="pc bpc" id="L1138" title="1 of 2 branches missed.">        if (igBatchReport == null) {</span>
<span class="nc" id="L1139">            throw new ApplicationException(SystemException.CODE_NOT_EXIST_BATCH_NUMBER, &quot;Batch number[&quot;</span>
                    + dto.getBatchNumber() + &quot;] not exist!!&quot;);
        }
<span class="fc" id="L1142">        instantBatchReportDto.setActualAmount(igBatchReport.getActualAmount());</span>
<span class="fc" id="L1143">        instantBatchReportDto.setTaxAmount(igBatchReport.getTaxAmount());</span>
<span class="fc" id="L1144">        instantBatchReportDto.setBatchNumber(igBatchReport.getBatchId());</span>
<span class="fc" id="L1145">        instantBatchReportDto.setTotalFail(igBatchReport.getFailedTicketsCount());</span>
<span class="fc" id="L1146">        instantBatchReportDto.setTotalSuccess(igBatchReport.getSucceededTicketsCount());</span>

<span class="fc" id="L1148">        List&lt;IGFailedTicketsReport&gt; list = iGFailedTicketsReportDao.findByBatchId(ctx.getOperatorId(),</span>
                dto.getBatchNumber());
<span class="pc bpc" id="L1150" title="2 of 4 branches missed.">        if (null != list &amp;&amp; list.size() &gt; 0) {</span>
<span class="fc bfc" id="L1151" title="All 2 branches covered.">            for (IGFailedTicketsReport igFailedTicketsReport : list) {</span>
<span class="fc" id="L1152">                InstantTicket instantTicket = new InstantTicket();</span>
<span class="fc" id="L1153">                instantTicket.setRawSerialNo(BaseTicket.descryptSerialNo(igFailedTicketsReport.getIgSerialNumber()));</span>
<span class="fc" id="L1154">                instantTicket.setErrorCode(igFailedTicketsReport.getErrorCode());</span>
<span class="fc" id="L1155">                instantBatchReportDto.getTickets().add(instantTicket);</span>
<span class="fc" id="L1156">                instantBatchReportDto.setTotalFail(instantBatchReportDto.getTotalFail() + 1);</span>
<span class="fc" id="L1157">            }</span>
        }

<span class="fc" id="L1160">        return instantBatchReportDto;</span>
    }

    @Override
    public InstantBatchReportDto ConfirmBatchValidation(Context response, InstantBatchReportDto dto)
            throws ApplicationException {
<span class="fc" id="L1166">        InstantBatchReportDto instantBatchReportDto = new InstantBatchReportDto();</span>
<span class="fc" id="L1167">        IGBatchReport igBatchReport = iGBatchReportDao.getByBatchId(response.getOperatorId(), dto.getBatchNumber());</span>
<span class="pc bpc" id="L1168" title="1 of 2 branches missed.">        if (igBatchReport == null) {</span>
            // if this batch number was not confirm before
            /*
             * 1,Check whether there are partial records for this batch, 2,Get all temp payout records
             */
<span class="fc" id="L1173">            BigDecimal totalAmount = this.getiGPayoutTempDao().getTotoalAmountBeforeTax(dto.getBatchNumber(),</span>
                    response.getOperatorId());
<span class="fc" id="L1175">            BigDecimal actualAmout = this.getiGPayoutTempDao().getActualAmount(dto.getBatchNumber(),</span>
                    response.getOperatorId());
<span class="fc" id="L1177">            Long succeededTicketsCount = this.getiGPayoutTempDao().getSucceededTicketsCount(dto.getBatchNumber(),</span>
                    response.getOperatorId());
            // 3,Generate new batchreport record

<span class="fc" id="L1181">            igBatchReport = new IGBatchReport();</span>
<span class="fc" id="L1182">            igBatchReport.setActualAmount(totalAmount);</span>
<span class="fc" id="L1183">            igBatchReport.setTaxAmount(totalAmount.subtract(actualAmout));</span>
<span class="fc" id="L1184">            igBatchReport.setOperatorId(response.getOperatorId());</span>
<span class="fc" id="L1185">            igBatchReport.setBatchId(dto.getBatchNumber());</span>
<span class="fc" id="L1186">            igBatchReport.setCreateTime(new Date());</span>
<span class="fc" id="L1187">            igBatchReport.setUpdateTime(new Date());</span>
<span class="fc" id="L1188">            igBatchReport.setId(this.getUuidManager().getGeneralID());</span>
<span class="fc" id="L1189">            igBatchReport.setSucceededTicketsCount(succeededTicketsCount);</span>

<span class="fc" id="L1191">            this.getiGBatchReportDao().insert(igBatchReport);</span>
            // 4,update ig ticket records to valid
<span class="fc" id="L1193">            this.getiGPayoutTempDao().validateAllTicket(dto.getBatchNumber(), response.getOperatorId());</span>
            // 5,add payout records
<span class="fc" id="L1195">            this.getiGPayoutTempDao().movePayoutData(dto.getBatchNumber(), response.getOperatorId());</span>
            // 6,add payout detail records
<span class="fc" id="L1197">            this.getiGPayoutDetailTempDao().movePayoutDetailData(dto.getBatchNumber(), response.getOperatorId());</span>
            // 7.
<span class="fc" id="L1199">            response.getTransaction().setTotalAmount(actualAmout);</span>
<span class="fc" id="L1200">            Object operatorOrMerchant = this.getBalanceService().balance(response, response.getTransaction(),</span>
                    BalanceService.BALANCE_TYPE_PAYOUT, response.getTransaction().getOperatorId(), true);
            /*
             * 8,update operator's payout credit
             */
            // 8.1 get all games of this batch
<span class="fc" id="L1206">            List&lt;Game&gt; list = this.getiGPayoutTempDao().getAllGamesOfThisBatch(dto.getBatchNumber(),</span>
                    response.getOperatorId());
<span class="pc bpc" id="L1208" title="2 of 4 branches missed.">            if (list != null &amp;&amp; list.size() &gt; 0) {</span>
<span class="fc" id="L1209">                Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span>

<span class="fc" id="L1211">                List&lt;GsonGame&gt; items = new LinkedList&lt;GsonGame&gt;();</span>

<span class="fc bfc" id="L1213" title="All 2 branches covered.">                for (Game game : list) {</span>
<span class="fc" id="L1214">                    BigDecimal creditAmount = this.getiGPayoutTempDao().getActualAmountByGame(game,</span>
                            dto.getBatchNumber(), response.getOperatorId());
                    // 1,deduct balance

<span class="fc" id="L1218">                    response.getTransaction().setGameId(game.getId());</span>
                    // // 2,calculating commission
<span class="fc" id="L1220">                    this.getCommissionBalanceService().calCommission(response, operatorOrMerchant);</span>

                    // adding trace logs
<span class="fc" id="L1223">                    GsonGame item = new GsonGame();</span>
<span class="fc" id="L1224">                    item.setGameId(game.getId());</span>
<span class="fc" id="L1225">                    item.setPrizeAmount(creditAmount);</span>
<span class="fc" id="L1226">                    items.add(item);</span>

                    /*
                     * this.getCreditService().credit(response.getTransaction().getOperatorId(),
                     * response.getTransaction().getMerchantId(), new BigDecimal(creditAmount), game.getId(), true,
                     * false, false);
                     */

<span class="fc" id="L1234">                }</span>
<span class="fc" id="L1235">                map.put(&quot;gameStat&quot;, items);</span>
<span class="fc" id="L1236">                response.getTransaction().setGameId(&quot;&quot;);</span>

<span class="fc" id="L1238">                TransactionMessage transMessage = new TransactionMessage();</span>
<span class="fc" id="L1239">                transMessage.setTransactionId(response.getTransaction().getId());</span>
<span class="fc" id="L1240">                transMessage.setResponseMsg(new Gson().toJson(map));</span>
<span class="fc" id="L1241">                response.getTransaction().setTransMessage(transMessage);</span>

                // response.getTransaction().getTransMessage().setResponseMsg();

            }
            // 8.remove temporary data

        }
<span class="fc" id="L1249">        instantBatchReportDto.setActualAmount(igBatchReport.getActualAmount());</span>
<span class="fc" id="L1250">        instantBatchReportDto.setTaxAmount(igBatchReport.getTaxAmount());</span>
<span class="fc" id="L1251">        instantBatchReportDto.setBatchNumber(igBatchReport.getBatchId());</span>
<span class="fc" id="L1252">        instantBatchReportDto.setTotalFail(igBatchReport.getFailedTicketsCount());</span>
<span class="fc" id="L1253">        instantBatchReportDto.setTotalSuccess(igBatchReport.getSucceededTicketsCount());</span>

<span class="fc" id="L1255">        List&lt;IGFailedTicketsReport&gt; list = iGFailedTicketsReportDao.findByBatchId(response.getOperatorId(),</span>
                dto.getBatchNumber());
<span class="pc bpc" id="L1257" title="2 of 4 branches missed.">        if (null != list &amp;&amp; list.size() &gt; 0) {</span>
<span class="fc bfc" id="L1258" title="All 2 branches covered.">            for (IGFailedTicketsReport igFailedTicketsReport : list) {</span>
<span class="fc" id="L1259">                InstantTicket instantTicket = new InstantTicket();</span>
<span class="fc" id="L1260">                instantTicket.setRawSerialNo(BaseTicket.descryptSerialNo(igFailedTicketsReport.getIgSerialNumber()));</span>
<span class="fc" id="L1261">                instantTicket.setErrorCode(igFailedTicketsReport.getErrorCode());</span>
<span class="fc" id="L1262">                instantBatchReportDto.getTickets().add(instantTicket);</span>
<span class="fc" id="L1263">                instantBatchReportDto.setTotalFail(instantBatchReportDto.getTotalFail() + 1);</span>
<span class="fc" id="L1264">            }</span>
        }

        // TODO Auto-generated method stub
<span class="fc" id="L1268">        return instantBatchReportDto;</span>
    }

    public CommissionBalanceService getCommissionBalanceService() {
<span class="fc" id="L1272">        return commissionBalanceService;</span>
    }

    public void setCommissionBalanceService(CommissionBalanceService commissionBalanceService) {
<span class="nc" id="L1276">        this.commissionBalanceService = commissionBalanceService;</span>
<span class="nc" id="L1277">    }</span>

    public BalanceService getBalanceService() {
<span class="fc" id="L1280">        return balanceService;</span>
    }

    public void setBalanceService(BalanceService balanceService) {
<span class="nc" id="L1284">        this.balanceService = balanceService;</span>
<span class="nc" id="L1285">    }</span>

    public BalanceTransactionsDao getBalanceTransactionsDao() {
<span class="nc" id="L1288">        return balanceTransactionsDao;</span>
    }

    public void setBalanceTransactionsDao(BalanceTransactionsDao balanceTransactionsDao) {
<span class="nc" id="L1292">        this.balanceTransactionsDao = balanceTransactionsDao;</span>
<span class="nc" id="L1293">    }</span>

<span class="fc" id="L1295">    private static class GsonGame {</span>

        String gameId;
        BigDecimal prizeAmount;

        public String getGameId() {
<span class="nc" id="L1301">            return gameId;</span>
        }

        public void setGameId(String gameId) {
<span class="fc" id="L1305">            this.gameId = gameId;</span>
<span class="fc" id="L1306">        }</span>

        public BigDecimal getPrizeAmount() {
<span class="nc" id="L1309">            return prizeAmount;</span>
        }

        public void setPrizeAmount(BigDecimal prizeAmount) {
<span class="fc" id="L1313">            this.prizeAmount = prizeAmount;</span>
<span class="fc" id="L1314">        }</span>

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.2.201302030002</span></div></body></html>